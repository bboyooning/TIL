## 목차

- [프로그래밍](#프로그래밍)

  - 프로그래밍이란?
  - 컴파일러와 인터프리터
  - 컴퓨팅 사고력
  - 컴파일(compile)
  - 컴파일러(compiler)와 인터프리터(interpreter)

- [자바스크립트](#자바스크립트)

  - 자바스크립트의 특징

- [변수](#변수)

  - 변수
  - 식별자
  - 변수 선언이란
  - 호이스팅
  - var 키워드의 문제점
  - let 키워드와 var 키워드의 차이점
  - TDZ
  - const 키워드의 특징
  - 식별자 네이밍 규칙
  - 네이밍 컨벤션
  - 리터럴

- [데이터 타입](#데이터-타입)

  - 데이터 타입의 종류는 어떤 것들이 있나
  - 심벌 타입이란?
  - 데이터 타입은 왜 필요할까
  - 정적 타이핑이 뭔가
  - 동적 타이핑이 뭔가

- [타입변환과 단축 평가](#타입변환과-단축-평가)

  - 명시적 타입 변환이 뭔가
  - 명시적 타입 변환 함수를 예를 들어볼 수 있나
  - 암묵적 타입 변환이 뭔가
  - truthy / falsy 한 값이 뭔가

- [배열](#배열)

  - 자바스크립트의 배열은 자료구조의 배열과 같나
  - 배열의 메서드는 어떤 종류가 있나
  - 고차 함수에 대해서 아나
  - forEach 메서드와 map메서드의 차이점에 대해 알고 있나

- [객체 리터럴](#객체-리터럴)

  - 자바스크립트에서 객체란 뭘까
  - 함수와 메서드의 차이점에 대해 알고 계신가
  - 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나

- [원시 값과 객체 비교](#원시-값과-객체-비교)

  - 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까
  - 값에 의한 전달이 뭔가
  - 참조에 의한 전달이 뭔가

- [함수](#함수)

  - 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나
  - 함수 선언문과 함수 표현식은 어떤 차이가 있나
  - 즉시 실행 함수(IIFE)에 대해 알고 있나 알고 있다면 아는 내용에 대해 말해보세요

- [스코프](#스코프)

  - 스코프가 뭔가
  - 스코프에는 어떤 종류가 있죠?
  - 렉시컬 스코프를 아나 안다면 렉시컬 스코프는 무엇을 의미하나
  - 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까

- [생성자 함수에 의한 객체 생성](#생성자-함수에-의한-객체-생성)

  - 생성자 함수가 뭔가
  - 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나
  - 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나

- [함수와 일급 객체](#함수와-일급-객체)

  - 일급 객체가 뭔가
  - 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나
  - 꼬리 질문) 함수형 프로그래밍이 뭔가
  - 꼬리 질문) 순수 함수가 뭔가 일반 함수와는 어떤 차이가 있죠?

- [프로토타입](#프로토타입)

  - 객체지향 프로그래밍은 무엇을 의미하나
  - 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나
  - 자바스크립트는 객체지향 프로그래밍 언어인가
  - 프로토타입이 뭔가

- [strict mode](#strict-mode)

  - strict mode가 뭔가
  - strict mode를 통해 무엇을 예방할 수 있죠?

- [빌트인 객체](#빌트인-객체)

  - 빌트인 객체가 뭔가 종류는 어떤게 있죠?
  - 래퍼 객체에 대해서 알고 있나

- [this](#this)

  - this가 뭔가
  - this 바인딩이란?
  - this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나

- [실행 컨텍스트](#실행-컨텍스트)

  - 실행 컨텍스트에 대해 말해보세요

- [클로저](#클로저)

  - 클로저에 대해서 아나
  - 클로저를 사용하면 뭐가 좋죠?
  - 클로저를 어떻게 생성하나

- [클래스](#클래스)

  - 자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나
  - 그럼 생성자 함수와 클래스는 어떤 차이가 있나
  - 클래스 정의
  - 클래스의 상속

- [스프레드 문법](#스프레드-문법)

  - spread 문법이 뭔가
  - 어떤 상황에서 사용할 수 있죠?

- [구조 분해 할당](#구조-분해-할당)

  - 구조 분해 할당이 뭔가
  - 구조 분해 할당은 크게 어떤 종류가 있나

- [브라우저 렌더링 과정](#브라우저-렌더링-과정)

  - 브라우저의 렌더링 과정에 대해 설명
  - 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나
  - `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까

- [DOM](#DOM)

  - DOM이 뭔가
  - DOM을 구성하는 건 뭐가 있나

- [이벤트](#이벤트)

  - 마우스 이벤트 타입에는 뭐가 있나 click 말고 클릭을 대체할 수 있는 이벤트가 있나
  - 그 외에 알고 있는 대표적인 이벤트가 있나
  - 이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나
  - 이벤트 전파(propagation)에 대해서 알고 있나
  - 이벤트 위임(delegation)에 대해서 알고있나
  - e.preventDefault 에 대해 알고 있나
  - e.stopPropagation

- [타이머](#타이머)

  - 호출 스케쥴링이 무엇인가
  - 타이머 함수에는 어떤 것들이 있나
  - 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나
  - 디바운스에 대해서 알고 있나
  - 쓰로틀에 대해서 알고 있나

- [비동기 프로그래밍](#비동기-프로그래밍)

  - 동기와 비동기의 차이점
  - 이벤트 루프와 태스크 큐
  - 마이크로태스크 큐
  - 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나

- [Ajax](#Ajax)

  - Ajax는 무엇이며 어떤 것을 담당하고 있는가
  - Ajax를 사용하면 기존 방식과 어떤 차이가 있을까
  - JSON 이 뭔가
  - JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나
  - Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나
  - XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나

- [REST API](#REST-API)

  - REST API가 뭔가
  - REST API의 구성은 어떤 것이 있나
  - REST API를 설계하는데 중요한 것이 있을까
  - HTTP 요청 메서드에 대해서 아는대로 설명
  - HTTP 상태 코드를 아는대로 설명

- [Promise](#Promise)

  - 콜백이란 뭐라고 생각하나
  - 프로미스가 뭔가
  - 프로미스 생성 방법
  - 프로미스의 상태를 나타내는 것은 어떤 것들이 있나
  - 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나

- [제너레이터와 async await](#제너레이터와-async-await)

  - 제너레이터란 뭔가 일반 함수와는 어떤 차이가 있는지
  - 제너레이터의 구조
  - async/await 가 뭔가 기존의 Promise와는 어떤 차이가 있는지
  - Promise와 async/await의 차이점 한 줄 요약

- [에러](#에러)

  - 에러처리를 왜 해야 하나
  - 자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까

- [모듈](#모듈)

  - 모듈이 뭔가

### 프로그래밍

- 프로그래밍이란?
  컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션 입니다. 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구를 설명하는 작업이며, 그 결과물이 바로 코드 입니다. 만들고자 하는 프로그램이 갖추어야 할 기능들은 어떤 것들이 있고, 또 이러한 기능들을 어떤 방식으로 구현할 것인지를 미리 생각해야만 효율적이고 좋은 프로그램을 만들 수 있습니다.
  <br>

  문제 인식과 프로그램 설계 단계가 프로그램의 설계도를 만드는 작업이라면, 프로그램 구현 단계는 설계도에 따라 직접 코딩(coding)을 수행하는 과정이라고 할 수 있습니다. 이후 테스트와 디버깅 단계를 통해 작성한 프로그램의 오류를 찾아 수정하여 배포할 수 있는 수준의 프로그램을 만들고, 이를 사용하면서 추가해야 되거나 수정해야 할 사항들이 있으면 유지보수하게 됩니다.
  <br>

- 컴퓨팅 사고력
  컴퓨터가 문제를 해결하는 방식처럼 복잡한 문제를 단순화하여 이를 논리적이고 효율적으로 해결하는 능력을 의미합니다.
  <br>

- 컴파일(compile)
  어셈블리어 또는 어셈블러 언어는 기계와 일대일 대응이 되는 컴퓨터 프로그래밍의 저수준 언어(기계 친화적 언어)입니다. 컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 됩니다.
  <br>

  때문에 통일된 언어체계로 작성한 코드의 필요성이 대두되고 여기서 고급 프로그래밍 언어가 나오게 됩니다. 컴퓨터는 고수준 언어로 작성한 코드를 바로 인식하지 못하기 때문에 이를 번역해줄 과정이 필요했고, 이를 `컴파일` 이라고 합니다.

- 컴파일러(compiler)와 인터프리터(interpreter)
  고급 프로그래밍 언어를 사용하게 되면서 이를 어셈블리어로 번역해주는 방식에는 2가지가 있는데 그것이 컴파일러와 인터프리터 방식 입니다.
  <br>

  `컴파일러` 는 프로그램 전체를 스캔하여 이를 모두 기계어로 번역합니다. 전체를 스캔하기 때문에 대개 컴파일러는 초기 스캔 시간이 오래 걸립니다. 하지만 초기 스캔을 마치면 실행파일을 만들어 놓고 다음에 실행할 때 이전에 만들어 놓았던 실행파일을 실행하기 때문에 전체 실행 시간만 놓고 보면 인터프리터보다 빠릅니다.
  또한, 오류 메세지를 생성할 때 전체 코드를 검사한 후에 오류 메세지를 생성하기 때문에 실행 전에 오류를 발견할 수 있습니다.
  <br>

  컴파일러는 고수준 언어로 작성된 소스를 기계어로 번역하고 이 과정에서 오브젝트 코드라는 파일을 만드는데, 이 오브젝트 코드를 묶어서 하나의 실행 파일로 다시 만드는 링킹 이라는 작업을 해야합니다. 그렇기 때문에 통상적으로 인터프리터 보다 많은 메모리를 사용해야 하는 단점이 있습니다.
  <br>

  컴파일러의 대표적인 언어로는 C, C++, JAVA 등이 있습니다.
  <br>

  `인터프리터` 는 컴파일러와는 반대로 프로그램 실행시 한 번에 한 문장씩 번역합니다. 그렇기 때문에 컴파일러보다 실행시간이 오래 걸립니다. 하지만, 인터프리터는 컴파일러와 같은 코드 생성과정이 없기 때문에 메모리 효율이 좋습니다.
  <br>

  인터프리터는 한번에 한 문장씩 번역하기 때문에 프로그램을 실행시키고 한 문장씩 번역될 때 오류를 만나게 되면 바로 프로그램을 중지합니다. 때문에 프로그램을 실행해봐야지만 오류 발견이 가능합니다.
  <br>

  인터프리터의 대표적인 언어로는 Python, Ruby, JavaScript 등이 있습니다.

### 자바스크립트

- 자바스크립트의 특징
  자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다.

  자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 `인터프리터` 언어 입니다. 인터프리터 단계와 실행 단계가 분리되어 있지 않고 반복적으로 수행되기 때문에 코드 실행 속도가 비교적 느리지만, 최근 웹 브라우저 대부분에는 실행 시간에 JS코드를 컴파일하는 JIT(Just In Time) 컴파일러가 내장되어 있어 실행속도가 매우 빨라졌습니다. 이는 자바스크립트를 활용한 고기능 웹 애플리케이션을 구현할 수 있게 된 중요한 요인 중 하나 입니다.
  <br>

  또한 동적 프로토타입을 상속하는 프로토타입 기반 객체지향 언어 입니다. 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있습니다.
  <br>

  자바스크립트는 동적 타입 언어입니다. 변수 타입이 없기 때문에 프로그램을 실행하는 도중 변수에 저장되는 데이터의 타입이 동적으로 바뀔 수 있습니다.
  <br>

  자바스크립트 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있으므로 함수가 일급 객체 입니다. 이러한 특성을 활용하면 고차 함수를 구현할 수 있어 함수형 프로그래밍이 가능해집니다. 또한 자바스크립트 함수는 클로저(Closure)를 정의하기 때문에, 클로저로 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있습니다.

### 변수

- 변수
  하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 뜻합니다.

- 식별자
  변수의 이름을 식별자 라고도 합니다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말하며, 식별자는 값이 아니라 메모리 주소를 기억합니다.
  또한 식별자 라는 용어는 변수 이름에만 국한해서 사용하는 것이 아닙니다. 변수, 함수, 클래스 등의 이름은 모두 식별자 입니다.
  <br>

  식별자인 변수 이름으로는 메모리 상에 존재하는 변수 값을 식별할 수 있고, 함수 이름으로는 메모리 상에 존재하는 함수를 식별할 수 있습니다.
  즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름 모두를 식별자 라고 합니다.

- 변수 선언이란
  변수 선언이란 변수를 생성하는 것을 의미합니다. 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.
  <br>

  변수를 사용하려면 반드시 선언이 필요합니다. 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용합니다.

- 호이스팅
  자바스크립트에는 var, let, const라는 키워드가 있고 또한 함수에서 변수 선언문을 최상단으로 끌어 올려주는것 처럼 보이는 호이스팅이라는 독특한 기능이 있습니다. 변수는 선언 초기화 할당순의 사이클을 가지고 있는데 var의 경우에는 선언을 하기도 전에 할당을 해도 에러가 발생하지 않습니다. 그 이유는 var로 선언한 변수는 호이스팅시 선언과 초기화를 동시에 하기 때문에 메모리를 undefinded로 만들어서 에러를 내보내지 않아서 결과적으로 버그를 야기할 수 있기 때문에 es6부터는 let과 const를 사용합니다. let과 const도 호이스팅을 하지만 선언과 초기화 단계 사이에 변수를 참조할 수 없는 tdz라는 일시적 사각지대 떄문에 참조에러를 내보내기 때문에 호이스팅이 일어나지 않는것처럼 보입니다 따라서 통상적으로 재할당 재선언이 안되는 const를 사용하고 재할당이 필요한 경우에 한해서 let을 사용합니다.
- var 키워드의 문제점

  1. 변수 중복 선언 허용
     var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는데, 이는 의도치 않게 변수 값이 재할당 되어 변경되는 부작용을 발생시킬 수 있습니다.
  2. 함수 레벨 스코프
     대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch)이 지역 스코프를 만듭니다. 이러한 특성을 블록 레벨 스코프 라고 합니다.
     <br>

     하지만, var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다. 이러한 특성을 함수 레벨 스코프 라고 합니다.

  3. 변수 호이스팅
     var 키워드로 선언된 변수는 선언과 동시에 undefined 로 초기화 되며, 런타임 즉 소스코드 평가 단계에서 스코프에 등록되기 때문에 실제 값이 할당되지 않더라도 undefined 를 가지고 있습니다. 이를 변수 호이스팅 이라 합니다.

- let 키워드와 var 키워드의 차이점
- TDZ
- const 키워드의 특징
- 식별자 네이밍 규칙
- 네이밍 컨벤션
- 리터럴

### 브라우저 렌더링 과정

- 브라우저의 렌더링 과정에 대해 설명

  1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청하면, 브라우저는 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받습니다.
  2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM 을 생성하고 이들을 결합하여 렌더 트리를 생성합니다.
  3. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고
  4. 이후 레이아웃을 바탕으로 브라우저 화면에 HTML 요소를 페인팅하면 렌더링이 완료됩니다.

- 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나

1. HTML/CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 <script> 태그나 자바스크립트 코드를 콘텐츠로 담은 <script> 태그를 만나면 DOM 생성을 일시 중단합니다.

2. 그리고 <script> 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 <script> 태그 내의 자바스크립트 코드를 파싱하기 위해 ② 자바스크립트 엔진에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료되면 ① 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

3. 자바스크립트 파싱과 실행은 ① 브라우저 렌더링 엔진이 아닌 ② 자바스크립트 엔진이 처리한다. ② 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어(low-level language)로 변환하고 실행하는 역할을 한다.

4. ② 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstract Syntax Tree: 추상적 구문 트리)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드(intermediate code)인 바이트코드를 생성하여 실행한다.

- 리플로우와 리페인트

- 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.
  이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우(reflow), 리페인트(repaint)라 한다.

- `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까

### 프로토타입

#### 객체지향 프로그래밍은 무엇을 의미하나

- 객체지향 프로그래밍은 여러개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말합니다.

#### 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나

- 객체지향 프로그래밍의 특징은 총 4가지 입니다.

1. 추상화

   - 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것으로, 객체를 구성할 수 있는 프로퍼티 중에서 필요한 속성만 간추려 내어 표현하는 것을 말합니다.

2. 캡슐화

   - 보통 데이터를 은닉시킨다고 표현하는데, 외부에서 쉽게 데이터를 접근할 수 없게 만들기도 하고, 데이터 구조와 데이터를 다루는 방법들을 목적에 따라 결합 시켜서 묶는 것 등을 캡슐화 라고 합니다.

3. 상속

   - 상위 개념의 특징을 하위 개념이 물려받는 것으로 부모의 메소드나 변수를 사용할 수 있는 것을 말합니다.

4. 다형성

   - 부모 클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것을 말합니다.

#### 자바스크립트는 객체지향 프로그래밍 언어인가

- 자바스크립트는 객체지향 프로그래밍 뿐 아니라 명령형, 함수형 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.
- 클래스 기반 객체지향 프로그래밍 언어와 달리 프로토타입 기반의 객체지향 프로그래밍 입니다.

#### 객체지향 프로그래밍과 함수형 프로그래밍의 차이

- 객체지향은 객체 안에 상태를 저장하고, 이 상태를 이용해서 메소드를 추가하고 상태변화를 설정하고 조정하기위해 다양한 기능을 사용한다. 이에 반해 함수형 프로그래밍은 상태를 제어하는것보다 상태를 저장하지 않고 없애는데 주력한다.
- 예를들면, 객체 지향은 상태를 저장하는 필드와 그 필드들을 이용해 기능을 제공하는 메소드를 만들고 클래스를 만듭니다. 반면 함수형은 몇몇 자료구조(list, map, set) 등을 이용해 최적화된 동작을 만들어낸다.

### HTTP

#### HTTP 와 HTTPS 의 차이점

- HTTP는 서버와 클라이언트간에 데이터를 주고받는 프로토콜 입니다. 이러한 HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기 때문에 보안적 허점을 가지고 있습니다.
- 이러한 문제를 해결하기 위해 등장한 것이 HTTPS 입니다.
- HTTP에 데이터 암호화가 추가된 프로토콜 입니다.
- 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있습니다. 현재는 모든 웹페이지에서 HTTPS 를 적용하는 방향으로 바뀌어가고 있습니다.

#### (참고) 공개키 방식?

- HTTPS는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화하고 있다. 공개키와 개인키는 서로를 위한 1쌍의 키이다.

  공개키: 모두에게 공개된, 또는 공개가 가능한 키
  개인키: 나만 가지고 알고 있어야 하는 키

- 공개키와 개인키로 암호화하면 다음과 같은 효과를 얻을 수 있다.

  - 공개키 암호화: 공개키로 암호화를 하면 개인키로만 복호화할 수 있다. -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.
  - 개인키 암호화: 개인키로 암호화하면 공개키로만 복호화할 수 있다. -> 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.

- HTTPS를 사용하기 위해서는 인증된 기관 CA(Certificate Authority)에 공개키를 전송하여 인증서를 발급받아야 한다.

#### HTTP 프로토콜의 특징

- HTTP 프로토콜은 connentionless, stateless, 즉 연결을 유지하지 않고 상태를 유지하지 않는다는 특성을 가지고 있습니다.
- 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리되기 때문에 이전에 보냈던 데이터 요청과 다음에 보낼 데이터 요청이 서로 관련이 없습니다.
- 이러한 특징 덕분에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생깁니다.

* connetionless

- 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버리는 특징
- HTTP 는 클라이언트가 서버에 요청하면, 서버는 요청에 응답한 후 접속을 끊는 특성이 있음

* stateless

- 통신이 끝나면 상태를 유지하지 않는 특징
- 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있음

#### 쿠키 / 세션

- HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠기 또는 세션을 사용합니다.
- HTTP 프로토콜은 connentionless, stateless 한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 합니다.
- 이 특성을 보완하기 위해 쿠키와 세션을 사용하게 됩니다.

- 쿠키?
- 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다.
- 클라이언트의 상태 정보를 로컬에 저장했다 참조하며,
- 사용자가 따로 요청하지 않아도 브라우저가 HTTP 헤더에 쿠키를 함께 보내어 자동으로 서버에 전송합니다.
- 클라이언트가 페이지를 요청하면 서버에서 쿠키를 생성하여 HTTP 헤더에 쿠키를 포함시켜 응답하고, 브라우저가 종료되어도 만료 기간까지 클라이언트에서 보관하게 됩니다.

- 세션?
- 세션은 쿠키를 기반하고 있지만, 세션은 서버 측에서 관리합니다.
- 서버에서는 클라이언트를 구분하기 위해서 세션 ID를 부여하며, 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증 상태를 유지합니다.
- 클라이언트가 서버에 접속 시 세션 ID를 발급 받는데, 이 세션 ID에 대해 쿠키를 사용하여 저장하고 가지고 있습니다. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달하여 요청합니다. 서버는 세션 ID를 전달받아 이를 이용하여 클라이언트 정보를 가져와서 사용합니다. 클라이언트 정보를 가지고 서버 요청을 처리하며 응답합니다.
- 보안 측면에서 쿠키보다 우수하지만, 세션은 서버의 처리가 필요하기 때문에 사용자가 많아질수록 서버 메모리를 많이 차지하게 되어 쿠키보다 속도가 느릴 수 있습니다.

- 쿠키와 세션의 차이?
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치 입니다.
- 쿠키는 클라이언트 로컬에 저장되는 반면, 세션은 서버의 자원을 사용합니다.
- 보안 측면에서 세션이 쿠키보다 우수하지만, 세션은 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문에 쿠키가 유리한 경우가 있습니다.
- 또한 쿠키는 만료시간이 있긴 하지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아있을 수 있지만,
- 세션의 경우 만료시간을 정할 수 있긴 하나 브라우저가 종료되면 만료 시간에 상관없이 삭제됩니다.

#### JWT

- HTTP 라는 프로토콜은 connectionless, stateless 의 특성 때문에 로그인 정보 등을 유지시키기 위해선 쿠키와 세션 등을 이용하게 되는데요.
- 보완이 필요한 정보의 경우엔 쿠키 보단 세션을 주로 이용하게 됩니다.
- 하지만 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 이러한 문제들을 보완하여 토큰 기반의 인증방식을 사용하는 추세입니다.
- 그 중 하나가 JWT(JSON Web Token) 입니다.
- 유저를 인증하고 식별하기 위한 토큰 기반의 인증 방식으로,
- 토큰 방식은 사용자가 로그인을 하면 서버에서 발행해주는 토큰을 가지고 브라우저의 저장소에 토큰을 유지시키는 방법입니다.
- JWT 는 암호화, 복호화를 통해 두 개체 사이에서 정보를 안전하게 주고 받을 수 있는 좋은 수단 입니다.

- JWT 토큰의 과정

#### REST Api

- REST(Representational State Transfer)의 약자로, 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미합니다.
- REST는 HTTP 장점을 최대한 활용할 수 있는 아키텍처로서, HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이고, 이러한 REST 를 기반으로 서비스 API를 구현한 것을 REST API 라고 합니다.
- 즉, REST 란

1. HTTP URI를 통해 리소스를 명시하고,
2. HTTP 메소드(GET, POST, PUT, DELETE)를 통해
3. 해당 자원(URI)에 대한 CRUD Operation 을 적용하는 것을 의미 합니다.

- CRUD Operation 이란 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 일컫는 말입니다.
- REST에서의 CRUD Operation 동작 예시
  ex) Create : 데이터 생성(POST), Read : 데이터 조회(GET), Update : 데이터 수정(PUT), Delete: 데이터 삭제(DELETE)

- REST 구성 요소

1. 자원(Resource): HTTP URI
2. 자원에 대한 행위: HTTP Method
3. 자원에 대한 행위의 내용: HTTP Message Pay Load

- RESTful 이란, REST의 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful 이라고 표현합니다.

# REST API 란?

### 비동기 프로그래밍

#### 동기와 비동기의 차이점

동기는 코드를 순차적으로 실행하고 비동기는 순서에 상관없이 코드를 실행시는것을 말합니다. 동기는 코드의 순서가 보장되어있어서 예측 가능하다는 장점이 있지만 코드가 실행 컨텍스트가 실행되고 종료 될때까지 작업이 멈춰있기 때문에 느리다는 단점이 있습니다.

비동기의 단점으로는 순서가 보장되지 않기 때문에 핸들링 하기 어렵다는 단점이 있지만 그 안에서 병렬로 작업이 진행되기 때문에 빠르다는 장점이 있습니다. 비동기를 제어하는 방법으로는 callback promise async await 순으로 발전했습니다.

콜백은 다른함수의 전달인자를 넘겨주는 함수를 말합니다 그런데 콜백을 사용하면 익명함수로 전달하는 과정에서 또 다시 콜백안에 함수 호출이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들어져서 가독성이 떨어집니다.

그래서 콜백을 보완하기 위해 프로미스가 나왔는데 프로미스로 비동기 처리를 하더라도 콜백처럼 .then 안에 프로미스 식으로 반복되어 프로미스 역시 가독성이 떨어지기에 es17부터 추가된 async await은 프로미스를 반환하지만 코드 가독성 문제를 해결하여 프로미스를 보완했습니다.

(자바스크립트에서 비동기를 써야할때 다른 로직을 동시에 실행시켜야할때)

#### 이벤트 루프와 태스크 큐

자바스크립트는 싱글 스레드로 동작하기 때문에 한 번에 하나의 태스크만 처리할 수 있습니다. 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴집니다.

예를 들어, HTML 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 합니다.
이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프(event loop) 입니다. 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나입니다.

구글의 v8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있습니다.

① 콜 스택 (call stack)

소스코드(전역 코드 및 함수 코드 등) 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택입니다.

함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행됩니다. 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트)가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않습니다.

②힙 (heap)

힙은 객체가 저장되는 메모리 공간입니다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조합니다.

메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 합니다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 합니다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다는 특징이 있습니다.

이처럼 콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐입니다.
비동기 처리에서 ① 소스코드의 평가와 ② 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당합니다.

예를 들어,

① 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만

② 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다

이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다

③ 태스크 큐 (task queue/event queue/callback queue)

setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역입니다.
태스크 큐와는 별도로 프로미스 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재합니다.

- 큐 (queue)
  스택 자료구조와 달리 선입선출(먼저 들어온 것이 먼저 나가는) 형식입니다.
  F.I.F.O(First In First Out) 라고도 부른다

④ 이벤트 루프 (event loop)

이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인합니다.
만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킵니다.
이때 콜 스택으로 이동한 함수는 실행됩니다. 즉, 태스크 큐에 일시 보관된 함수들을 비동기 처리 방식으로 동작합니다.

#### 마이크로태스크 큐

마이크로태스크 큐 는 태스크큐 와 별도의 큐로 후속 처리 메서드의 콜백 함수가 일시 저장됩니다.

그 외의 비동기 함수 ① setTimeout/ setInterval ② HTTP 요청 ③ 이벤트 핸들러 의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장됩니다.

콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로태스크 큐는 태스크 큐보다 우선순위가 높습니다.

#### 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나

마이크로태스크 큐는 태스크 큐보다 우선순위가 높습니다.

따라서 이벤트 루프에서 마이크로태스크 큐에 쌓인 태스크를 먼저 콜 스택에 올려준 뒤, 태스크 큐에 잔여 태스크를 콜 스택에 올립니다.
