## 목차

- 리액트
- 리액트는 프레임워크 or 라이브러리 ?
- 리액트를 사용하는 이유
- virtual DOM
- 리액트에서 클래스 컴포넌트와 함수 컴포넌트의 차이
- 리액트에서 함수형 컴포넌트라고 부르지 않고 함수 컴포넌트라고 부르는 이유
- props와 state의 차이
- Props가 컴포넌트간에 전달받는 것이라고 했는데 자식에서 부모로도 전달할 수 있는가
- FLUX
- 상태 관리 도구의 필요성
- 리덕스
- 리덕스의 기본 원칙
- 리액트에서 state의 불변성을 유지해야 하는 이유
- 리듀서 내부에서 불변성을 지키는 이유? 전개 연산자의 단점을 해결할 수 있는 방법
- 리액트 사용시에 부수효과로 인해 생기는 문제점
- 부수 효과를 일으키는 함수 (불순 함수)
- 부수 효과를 일으키지 않는 함수 (순수 함수)
- 컴포넌트의 라이프 사이클 메서드
- 메서드 종류
- Hooks의 종류
  - useState
  - useEffect
  - useReducer
  - useMemo
  - useCallback
  - useRef
  - useMemo ↔️ useCallback
- 리액트에서 setState는 비동기 or 동기?
- setState가 비동기 동작을 취했을 때 얻을 수 있는 이점
- useLayoutEffect
- 리액트의 성능개선 방법
- 컴포넌트에서 이벤트를 실행시키기 위한 핸들링 방법
- SPA 장단점
- SSR
- SEO
- TTV, TTI
- 하이드레이션
- Next.js 의 렌더링 수행 방식
- Next.js 장단점
- Next.jsr 를 구성하는 기본 설정 파일
- 사전 렌더링을 위해 사용해 본 함수가 있다면?
- Suspense

<br>

- 리액트 네이티브
- 리액트 ↔️ 리액트 네이티브
- 리액트 네이티브 ↔️ Flutter
- Expo ↔️ react-native-cli
- 리액트 네이티브에서 axios 말고 fetch 쓰는 이유
- iOS, Android와 RN이 상호작용 하는 방식
- RN navigation

<br>

### 리액트는 프레임워크 or 라이브러리 ?

- 결론적으로 리액트는 사용자 인터페이스를 만들기 위한 JS 라이브러리 입니다.

- 프레임워크 란 애플리케이션 개발시 코드의 품질, 필수적인 코드, 알고리즘, 암호화, 데이터베이스 연동 같은 기능들을 어느정도 구성이 되어있는 뼈대(구조)를 제공하도록 만들어진 것을 말합니다. 제어 반전이 적용된 구조로 외부 라이브러리 코드가 프로그래머가 작성한 코드를 호출합니다.
- 원하는 기능 구현에 집중하여 개발할 수 있도록 필요한 기능을 갖추고 있는 것, 일정한 형태를 가지고 다양한 형태의 결과물을 만드는 것.
- 즉, 개발 구조나 설계시 제공되는 인터페이스 집합으로 어느정도 프로그래머가 제공된 프레임워크 구조에서 개발을 해야합니다.
  <br>

- 전통적인 프로그래밍 흐름을 따르는 라이브러리는 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용합니다.
- 라이브러리는 특정 기능에 대한 API(도구/함수)를 모은 집합입니다. 그 기능을 사용하기 위해 불러와서 호출하는 방식입니다.
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 동작하는 중에 필요한 기능이 있을때 능동적으로 라이브러리를 사용합니다.

<br>

- 즉, 애플리케이션의 flow 를 누가 제어하느냐에 따라 이 둘을 구분하게 됩니다.
- 따라서, 애플리케이션 흐름을 직접 제어하는 리액트는 라이브러리 입니다.

### 리액트를 사용하는 이유

- 리액트를 사용하는 이유
  1. 컴포넌트 기반의 화면 구성으로 유지보수가 용이
  2. virtual DOM 을 활용한 빠른 렌더링
  3. SPA(Single Page Application)
  4. 생태계가 넓고 다양한 라이브러리 사용이 가능하며, 리액트 네이티브를 활용하여 앱 개발까지 가능

### Virtual DOM

- Virtual DOM
  DOM(Document Object Model)은 XML 이나 HTML 문서에 접근하기 위한 일종의 인터페이스 입니다. DOM은 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕습니다.

  `HTTP response > DOM tree > CSSOM tree > Render tree > painting `

  DOM은 새로운 요청이 있으면 위와 같은 형태를 거쳐 리렌더링을 하게 됩니다.
  DOM의 속도는 느리지 않지만, 매번 새롭게 구성하기 때문에 변경되는 양이 많으면 퍼포먼스가 떨어지게 됩니다. 이를 개선하기 위해서 Virtual DOM을 사용하게 됩니다.

  리액트는 virtual DOM 을 사용하여 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다. 전체 UI를 Virtual DOM 에 리렌더링하고, 이전 내용과 현재 내용을 비교하여 바뀐 부분만 실제 DOM에 적용시킵니다.

  리액트와 Virtual DOM 이 언제나 제공할 수 있는 것은 바로 업데이트 처리의 간결성 입니다.
  UI를 업데이트 하는 과정에서 생기는 복잡함을 모두 해소하고, 더욱 쉽게 업데이트에 접근할 수 있습니다.

### 리액트에서 클래스 컴포넌트와 함수 컴포넌트의 차이

#### 클래스 컴포넌트

- 객체 지향 프로그래밍 구조를 띄고 있으며, state 초기화 하기 위해서는 constructor(생성자)함수를 필요로 합니다.
- 생성자 함수를 통해 state 를 초기화 해야 하기 때문에 함수 컴포넌트에 비해 코드가 길어지고 사이즈가 커질 수 있습니다.
- state 기능 및 라이프 사이클 기능을 사용할 수 있으며 임의의 메서드를 정의할 수 있습니다.
- render 함수가 꼭 있어야 하며, 그 안에서 보여주어야 할 JSX 를 반환해야 합니다.

#### 함수 컴포넌트

- Hooks 를 이용하여 생성자 함수 통해 state 초기화를 하지 않아도 사용이 가능합니다.
- 선언하기가 좀 더 편한하고 메모리 자원을 덜 사용합니다.
- 제공되는 Hook 함수 뿐만 아니라 커스텀 Hook 을 생성하여 동작시킬 수 있습니다.
- 프로젝트를 완성하여 빌드한 후 배포할 때에도 함수 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작습니다.
- 함수 컴포넌트는 state 와 라이플 사이클 API 의 사용이 불가능 했었는데, v16.8 업데이트 이후에 적용된 Hooks 를 통해 이를 해결할 수 있게 되었습니다.

### 리액트에서 함수형 컴포넌트라고 부르지 않고 함수 컴포넌트라고 부르는 이유

- 리액트에서 사용하는 함수 컴포넌트는 Hook 을 사용하고, 이 Hook 으로 Side Effect 를 빈번히 일으키기 때문에 함수형 프로그래밍이 아닙니다.

함수형 프로그래밍은 순수 함수를 지향하는데, Side Effect 를 빈번히 일으키는 리액트의 함수 컴포넌트가 함수형 컴포넌트로 보기에는 어려움이 있습니다.

### props 와 state 차이

- props : props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props 를 읽기 전용으로만 사용할 수 있습니다. props 를 바꾸기 위해선 부모 컴포넌트에서 변경해야 합니다.

- state : 컴포넌트 내부에서 바뀔수 있는 값을 의미합니다.

### props가 컴포넌트간에 전달받는 것이라고 했는데 자식에서 부모로도 전달할 수 있는가

- props 는 부모 컴포넌트에서 설정할 수 있으며, 부모에서 자식으로만 데이터를 줄 수 있습니다.
- 자식 props 를 통해 부모에게 데이터를 줄 수 없고, 함수를 이용해야 합니다.
- 부모가 함수를 넣어서 props 로 넘겨주면, 자식이 데이터를 파라미터로 넣어 호출하는 방식으로 동작합니다.
- 즉, 부모가 props 로 함수를 넘겨주면, 자식이 그 함수를 이용해 값을 건네주는 방식입니다.

### FLUX

- 리덕스는 메타(구 페이스북)에서 리액트가 함께 소개한 FLUX 아키텍쳐로 구현한 라이브러리 입니다.
- FLUX 란 라이브러리나 프레임워크가 아닌 추상적인 개념입니다.
- MVC 패턴에서 쌍방향적인 데이터 흐름을 강조했던 것과 달리, FLUX 패턴에서는 단방향 데이터 흐름을 강조합니다.
- MVC 패턴의 경우 사용자의 어떠한 행위(액션)가 있을 때, 이를 바탕으로 설계된 컨트롤러를 통해 모델을 변화하고 이를 뷰에 반영합니다. 모델과 뷰가 복잡하게 얽히게 되면 뷰가 변경되었는지 제대로 확인할 수 없게 됩니다.
- 이를 해결하기 위해 나온 단방향 데이터 흐름을 제어하는 패턴이 FLUX 입니다.
- 사용자의 행위 Action 은 Dispatcher 에 의해 통제되고, Dispatcher 가 Store 를 업데이트 하고 변경된 Store 에 대한 뷰를 리렌더링 합니다.
- FLUX 패턴은 단방향적인 데이터 흐름 구조를 통해 어떤 액션이 디스패처에 의해 어떤 결과를 낳고 변화하는지 명확하게 알 수 있습니다.

### 상태 관리 도구의 필요성

- 상태?

  - React 에서 State 는 component 안에서 관리되고 시간이 지나면서 바뀌는 동적인 데이터
  - Component 간의 정보 공유
    - 자식 컴포넌트들 간의 다이렉트 데이터 전달은 불가능
    - 부모 컴포넌트를 통해 주고 받게 되는데 자식 컴포넌트들이 많아지면 상태 관리가 매우 복잡해짐
    - 상태를 관리하는 상위 컴포넌트에서 계속 내려받아야 함(Props Drilling 이슈)

- 이러한 상태 관리의 복잡성을 해결해주는 라이브러리를 활용!

  - 전역 상태 저장소를 제공하여, 어디서든 해당 저장소에 접근할 수 있어 Props Drilling 이슈를 해결할 수 있습니다.

- 좋은 상태 관리란?

  - State 는 관련 컴포넌트들과 최대한 가까이 배치되는 것이 좋습니다.
  - State 가 관련 컴포넌트와 멀어질수록 상태와 컴포넌트 사이에 있는 관련 없는 컴포넌트의 리렌더까지 일으킬 위험이 큽니다.
  - 또한 State 들은 관심사에 따라 잘 분리가 되어야 코드 수정시 Side Effect 를 최소화 할 수 있습니다.
  - 서로 관련 없는 컴포넌트들의 상태가 한번에 관리되면 결합도가 높아지게 되고 후에 어플리케이션이 비대화 될수록 의도치 않은 영향을 줄 수 있는 가능성이 높아지기 때문입니다.
  - 코드들은 격리되어 있지 않아 코드의 재사용성 또한 떨어집니다.

- 상태 관리 종류

  - React Context
  - Redux
  - MobX

- 가장 많이 사용되는 상태 관리 라이브러리는 Redux 입니다.

### 리덕스

<img src="https://velog.velcdn.com/images%2F404%2Fpost%2Fc8b85412-db74-49f3-b223-e0a35e1465b6%2Fredux-data-flow.gif" alt="redux">

- 리덕스란 자바스크립트 상태관리 라이브러리 이며, 가장 많이 사용되고 있는 라이브러리 입니다.
- React + Flux 구조에 Reducer 를 결합한 Redux
- 리덕스는 리액트, 앵귤러, 바닐라js 등 이용이 가능한 라이브러리
- 리덕스는 전역 상태 저장소를 제공하기 때문에 리액트의 Prop Drilling 문제와 여러 복잡해지는 상태 공유에 따른 컴포넌트 간 의존성 문제를 해결합니다.
- 리덕스는 Store 라는 하나뿐인 데이터 공간을 가지고 있으며, 이 공간에서만 데이터가 나옵니다.
- 리액트에서는 setState 메소드를 활용해야지만 상태 변경이 가능하듯, 리덕스에서도 Action 이라는 객체를 통해서만 상태 변경이 가능합니다.
- 변경은 순수 함수로만 가능하며, 이는 리듀서와 연관되는 개념입니다.

- 리덕스는 이럴때 사용합니다.

  - 앱의 여러 위치에서 필요한 많은 양의 상태들이 존재할 때(전역 상태가 필요하다고 느껴질 때)
  - 상태들이 자주 업데이트 될 때
  - 상태를 업데이트 하는 로직이 복잡할 때
  - 많은 사람들에 의해 코드가 관리될 때
  - 상태가 업데이트 되는 시점을 관찰할 필요가 있을 때

- 리덕스의 세가지 원칙

1. 하나의 애플리케이션 안에는 하나의 Store만 사용하자!
2. 상태를 변화시키는 것은 오직 Action 을 일으키는 것!
3. 변화를 일으키는 Reducer 함수는 순수 함수이어야만 한다!

- Reducer 함수는 이전 상태와 액션 객체를 파라미터로 받음
- 파라미터 외의 값에는 의존하면 안됨
- 이전 상태는 절대 건들지 않고, 변화를 준 새로운 상태 객체를 만들어 반환
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환

- Store

  - 상태가 관리되는 오직 하나의 공간으로, 컴포넌트와는 별개로 스토어 라는 공간이 있어서 그 스토어 안에 앱에서 필요한 상태를 담습니다.
  - 컴포넌트에서 상태 정보가 필요할 때 스토어에 접근합니다.

- Action

  - 앱에서 스토어에 운반할 데이터를 말합니다. 자바스크립트 객체 형식으로 되어 있습니다.

- Reducer

  - Action 을 Reducer 에 전달하고, 이 Reducer 가 Store 상태를 업데이트 합니다.
  - Action 을 Reducer 에 전달하기 위해서는 dispatch() 메소드를 사용합니다.
  - 즉, Action 객체가 dispatch() 메소드에 전달되고, dispatch() 를 통해 Reducer 를 호출하여 Reducer 는 새로운 Store 를 생성합니다.

- 이러한 공식을 따르는 이유는 `데이터가 한 방향으로만 흘러야 하기 때문` 입니다.

- Redux 에서 이를 구현하는 두 가지 방법은

- mapStateToProps()
- Redux hooks

  - useSelector
  - useDispatch

- Redux 장점

  - 데이터의 중앙집권화
  - 컴포넌트 상태 관련 로직을 따로 분리시켜 효과적으로 관리할 수 있고,
  - 상태를 공유할 때에도 다른 컴포넌트를 거치지 않고 Store 를 통해 전달이 가능하여 편리합니다.
  - 유지보수에 용이
  - 데이터가 단방향으로 흐르기 때문에 버그를 에측하기 쉽고, 디버깅에 유리
  - 순수함수를 사용하기 때문에 상태 예측이 가능하고, 데스트를 붙이기 용이합니다.

- Redux 단점

  - 초기에 state 업데이트에 맞는 Action 값들과 dispatch(), Reducer 들 등 미리미리 전부 만들어줘야 하기 때문에 복잡합니다.

<br>

### 리액트에서 리덕스를 이용한 상태 관리하기

1. 리액트 프로젝트에 모듈을 다운 받음

- npm install redux react-redux
- package.json 에서 확인 가능

2. 코드 분할(Code Splitting)

- 스크립트를 하나의 큰 파일로 로드하는 대신 더 작은 부분으로 나누고 해당 페이지에 필요한 것만 로드하는 기술
- src 폴더 안에 actions, reducers, store, components, pages 폴더로 분할
- 이때, components 폴더는 프리젠테이션 컴포넌트, pages 폴더는 컨페이너 컴포넌트로 나눔
- Store 는 하나의 리듀서만 관리할 수 있지만, 리듀서를 여러개 나눠서 하나로 합치는 것 가능

3. Reducer 에서 순수함수로 상태 업데이트 하는 방법

- Object.assign() 이용
- `return Object.assign({}, state, {새로 업데이트 할 것})`
- Spread 문법
- `return {...state, {새로 업데이트 할 것}}`

4. 최상위 index.js 에 Store 를 연결

<br>

### 리액트에서 state의 불변성을 유지해야 하는 이유

- 리액트에서 state값이 객체인 경우 setState를 통해 상태값을 업데이트 시킬때, spread operator를 사용해서 기존의 state값은 유지시키고 그것을 복사해서 업데이트한 값으로 상태를 바꿔줍니다. 이는 리액트에서 불변성을 지켜야 하는 이유와 관련이 깊습니다.
- 불변성은 어떤 값을 직접적으로 변경하지 않고 새로운 값을 만들어내는 것입니다.
- 이 불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못하게 됩니다.
- 우리가 state를 바꾸고 돔을 다시 만들려면, 새로운 객체나 배열을 만들어 새로운 참조값을 만들고 react에게 이 값은 이전과 다른 참조값임을 알려야 합니다.
- 따라서 기존의 state 값은 변하지 않도록 불변하게 만들고 새롭게 복사한 객체로 업데이트를 시켜 이전과 다른 값임을 알려야 합니다.
- 이렇게 state 값을 포함한 변수도 불변성을 갖게 해야 다른 버그나 예외사항이 일어나지 않는다.

- React에서 immutable variable을 만드는 여러가지 방법이 있습니다.
  - 자바스크립트 표준 함수 ES6 Object.assign() 또는 object-rest-spread
  - 자바스크립트 라이브러리 immutable-js
  - react공식 문서에서 추천하는 패키지인 immutability-helper

### 리듀서 내부에서 불변성을 지키는 이유? 전개 연산자의 단점을 해결할 수 있는 방법

- 컴포넌트는 총 4가지 경우에 업데이트를 합니다.

  - props 변경
  - state 변경
  - 부모 컴포넌트가 리렌더 될 때
  - this.forceUpdate 로 강제로 렌더링 트리거할 때

- 리듀서는 서버에서 넘겨받는 정보를 저장하고 전역으로 해당 객체를 사용할 수 있는 저장소 역할을 합니다.
- 불변성을 지킴으로써 각각의 고유한 참조값을 가지는 객체를 복사해서 사용함으로써 어떤 함수가 호출됐을 때 같은 객체를 참조한다면 생길 수 있는 불필요한 리렌더링과 부수효과를 줄일 수 있습니다.
- 하지만 `...spread` 연산자 사용해 객체를 복사하여 사용할 경우 객체의 깊이에 따라 로직 구성이 어려울 수 있습니다. (spread 연산자는 1depth 값에서만 깊은 복사를 실행함)
- 이를 해결하기 위한 라이브러리가 immer 라이브러리
- produce, draft 키워드 사용하여 spread 연산자 사용하지 않고 불변성을 유지해주며 불필요한 부수효과(Side Effect)를 막아줍니다.

### 리액트 사용시에 부수효과로 인해 생기는 문제점

- 부수효과(Side Effect)는 함수가 만들어진 목적과는 다른 효과 또는 부작용 입니다.
- 함수에 예상할 수 없는 일이 생길 가능성이 존재한다면 이 함수는 부수 효과를 가질 수 있는 함수가 됩니다.

### 부수 효과를 일으키는 함수(불순 함수)

- 비동기 요청을 보내는 함수는 요청에 실패할 가능성이 있고,
- 매개변수로 들어온 값을 직접 변경하는 함수,
- 입력을 포함하는 함수도 입력에 따라 출력이 달라질 가능성이 있어서 순수함수가 될 수 없습니다.

### 부수 효과를 일이키지 않는 함수(순수 함수)

- 함수의 매개변수로 들어온 값을 직접 변경하지 않는 것으로도 순수함수가 될 수 있습니다.

```js
// 매개변수의 값을 직접 변경하는 불순 함수
const addSixImpure = (arr) => {
  // 매개변수에 직접 추가
  arr.push(1);
  return arr;
};

// 매개변수를 복사한 값을 변경하는 순수 함수
const addSixPure = (arr) => {
  newArr = [...arr, 1];
  return newArr;
};
```

- 순수함수가 많아질 수록 코드를 더 쉽게 예측할 수 있고,
- 선언된 변수들을 직접 조작하지 않을수록 함수들은 부수효과 없이 개발자들의 의도대로 움질일 가능성이 높습니다.

- 즉, React state 는 직접 조작을 피하는 방식으로 부수효과를 방지합니다.
  (state, props 가 변경될 때 리렌더링 되기 때문에 의도치 않게 부수효과를 가진 함수들로 인해 불필요한 리렌더링이 잦아질 수 있습니다.)

- Redux 의 Reducer 는 순수 함수이어야만 하는데, store 값을 변경하는 함수가 부수효과를 동반하지 않아야 store 내부의 값들이 안전하게 보호될 수 있기 때문입니다.

- 또한 순수함수는 같은 입력에 대해 항상 같은 출력값을 보장하기 때문에, 테스트가 용이합니다.

- 부수효과가 있는 배열의 프로토타입 메서드
  - Array.isArray
  - Array.prototype.indexOf
  - Array.prototype.push (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.pop (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.unshift (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.shift (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.concat
  - Array.prototype.splice 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.slice
  - Array.prototype.join 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.reverse 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.fill 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.includes

### 컴포넌트의 라이플 사이클 메서드

- will 접두사가 붙은 메서드 : 어떤 작업을 작동하기 전에 실행되는 메서드
- Did 접두사가 붙은 메서드 : 어떤 작업을 작동한 후에 실행되는 메서드
- 이 메서드들은 우리가 컴포넌트 클래스에서 덮어써 선언함으로서 사용할 수 있습니다.
- 라이프 사이클은 총 3가지(마운트, 업데이트, 언마운트) 카테고리로 나눕니다.

- 마운트

  - DOM 이 생성되고 웹 브라우저상에 나타나는 것을 마운트라고 함
  - componentDidMount : 컴포넌트가 웹 브라우저 상에 나타난 후 호출하는 메서드

- 업데이트

  - props 변경
  - state 변경
  - 부모 컴포넌트가 리렌더링 될 때
  - this.forceUpdate 강제로 렌더링 트리거할 때
  - componentDidUpdate : 컴포넌트 업데이트(리렌더링) 후 호출하는 메서드

- 언마운트
  - 컴포넌트를 DOM 에서 제거하는 것
  - componentWillUnmount : 컴포넌트가 웹 브라우저 상에서 사라자기 전에 호출하는 메서드

### Hooks

- 리액트 버전 16.8에 새로 도입된 기능으로
- 함수 컴포넌트에서도 상태 관리 할 수 있는 useState,
- 렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공하여
- 기존의 함수 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해줍니다.

  - useState

    - 가장 기본적인 Hook
      `const [state, setState] = useState(초기값)`
    - state 는 변수, setState 는 state 를 변경시켜주는 함수
    - state, setState 를 return 하면서 초기값을 설정해주는 Hook
    - setState 함수를 이용하여 값을 변경해야지만 state 값이 변경되었다는 것을 인식하여 화면을 렌더링 합니다.
    - useState 는 리렌더링이 될 때 새로운 함수를 만들어주며, 각각의 함수는 고유의 state와 props를 기억하고 있습니다.

  - useEffect

    - 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정해주는 Hook
    - useEffect 는 기본적으로 렌더링 되고 난 직후마다 실행되며, 두번째 파라미터 배열, 즉 의존성 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.
    - 컴포넌트가 렌더링 된 이후에 어떤 일을 수행할 지 정해줄 수 있습니다.
    - 페이지가 처음 렌더링 되고 난 후 useEffect 는 무조건 한번 실행됩니다.
    - useEffect 에 배열로 지정한 useState 값이 변경될 때 실행되게 합니다.
    - 처음 렌더링만 실행하고 싶을 때는 의존성 배열에 빈배열을 작성합니다.
      `useEffect(() => {작업 내용}, [])`
    - 특정 값이 업데이트 될 때만 실행하고 싶다면, 의존성 배열에 useState 를 통해 관리되는 상태값이나 props 로 전달받은 값을 넣어주면 됩니다.
      `useEffect(() => {작업 내용}, [특정 값 업데이트를 위한 값])`

  - useReducer
    - useState 보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용하는 Hook
    - Reducer 는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션 값을 전달 받아 새로운 상태에 반환하는 함수 입니다.
    - Reducer 함수에서 새로운 상태를 만들 때는 반드시 불변성을 지켜주어야 합니다.
  - useMemo
    - useMemo 를 사용하면 함수 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.
    - 특정 `값` 이 바뀌었을 때만 연산을 실행하고, 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식입니다.
  - useCallback
    - useCallback 을 사용하면 렌더링 성능 최적화가 가능합니다.
    - 이 Hook을 사용하면 만들어놨던 함수를 재사용할 수 있습니다.
    - useCallback 의 첫번째 파라미터에는 생성하고 싶은 함수를 넣고, 두번째 파라미터에는 배열을 넣으면 됩니다.
    - 두번째 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야 합니다.
  - useRef
    - 바닐라 자바스크립트에서 특정 DOM 요소를 조작하기 위해 querySelector 혹은 getElementById 등을 사용했다면,
    - 리액트에서 특정 DOM에 접근할 때 useRef Hook 을 이용합니다.
    - useRef 는 .current 프로퍼티에 변경 가능한 값을 담고있는 객체입니다.
    - .current 프로퍼티를 변경하더라도 리렌더링을 유발하지 않습니다.
    - ref 객체 안의 값은 리액트 생명주기에 독립적 이기 때문입니다.
  - useMemo ↔️ useCallback

    - 리액트에서 사용하는 컴포넌트는 다음과 같은 경우에 리렌더 됩니다.

      - props 변경
      - state 변경
      - 부모 컴포넌트가 리렌더링 될 때

    - 불필요한 렌더링은 성능 저하에 가장 큰 원인이 되기도 합니다.
    - 이렇게 특정 상황(값 또는 함수 변경)에 맞게 리렌더링 될 수 있도록 useMemo 와 useCallback 을 사용합니다.
    - 의존성 배열을 사용하여 어떤 값에 의해 의해 확인될 수 있도록 합니다.

    - useMemo 는 메모이제이션된 `값`을 반환
    - useCallback 은 메모이제이션 된 `함수`를 반환
    - `메모이제이션` : 프로그램 실행 시 이전에 계산한 값을 저장, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식

### 리액트에서 setState는 비동기 or 동기?

- state 값을 갱신하는 setState 함수는 비동기로 동작하는 Hook 함수 입니다.
- 리액트는 state, props 값의 변경에 따라 리렌더링이 일어납니다.
- setState 를 비동기 함수로 처리해서 컴포넌트 내 비동기 함수를 처리하는 콜백 큐가 비워지면 리렌더링 되도록 설계합니다.
- 즉, 해당 함수 내에서 동기적으로 실행되는 함수가 모두 실행된 뒤에 마지막에 setState 를 처리한다.

### setState가 비동기 동작을 취했을 때 얻을 수 있는 이점

- setState 가 비동기 동작을 취함으로써 자바스크립트 내의 실행 컨텍스트 스택이 돌아갈 때 동기적으로 실행되는 함수들을 모두 동작한 뒤에 큐에 존재하는 비동기 함수들을 이벤트 루프에 의해 꺼내와서 실행시킵니다.
- 불필요한 리렌더링을 줄여줘서 성능이 개선됩니다.

### 리액트 네이티브에서 axios 말고 fetch 쓰는 이유

- axios 는 라이브러리로 다운받아 따로 import 해야 하지만, fetch 는 자바스크립트가 가진 내장 라이브러리 라서 따로 import 하지 않고도 쓸 수 있어서 빌드 시에 용량이 줄어든다.
- 또한 리액트 라이브러리는 버전이 빠르게 업데이트 되는 특성이 있기 때문에 최대한 라이브러리 의존성을 낮춰야 한다.
