## 목차

- 리액트
- 리액트는 프레임워크 or 라이브러리 ?
- 리액트를 사용하는 이유
- virtual DOM
- 리액트에서 클래스 컴포넌트와 함수 컴포넌트의 차이
- 리액트에서 함수형 컴포넌트라고 부르지 않고 함수 컴포넌트라고 부르는 이유
- props와 state의 차이
- Props가 컴포넌트간에 전달받는 것이라고 했는데 자식에서 부모로도 전달할 수 있는가
- FLUX
- 상태 관리 도구의 필요성
- 리덕스
- 리덕스의 기본 원칙
- 리액트에서 state의 불변성을 유지해야 하는 이유
- 리듀서 내부에서 불변성을 지키는 이유? 전개 연산자의 단점을 해결할 수 있는 방법
- 리액트 사용시에 부수효과로 인해 생기는 문제점
- 부수 효과를 일으키는 함수 (불순 함수)
- 부수 효과를 일으키지 않는 함수 (순수 함수)
- 컴포넌트의 라이프 사이클 메서드
- 메서드 종류
- Hooks의 종류
  - useState
  - useEffect
  - useReducer
  - useMemo
  - useCallback
  - useRef
  - useMemo ↔️ useCallback
- 리액트에서 setState는 비동기 or 동기?
- setState가 비동기 동작을 취했을 때 얻을 수 있는 이점
- useLayoutEffect
- 리액트의 성능개선 방법
- 컴포넌트에서 이벤트를 실행시키기 위한 핸들링 방법
- SSR ↔️ CSR
- SEO
- TTV, TTI
- SPA 장단점
- 하이드레이션
- Next.js 의 렌더링 수행 방식
- Next.js 장단점
- Next.jsr 를 구성하는 기본 설정 파일
- 사전 렌더링을 위해 사용해 본 함수가 있다면?
- Suspense

<br>

- 리액트 네이티브
- 리액트 ↔️ 리액트 네이티브
- 리액트 네이티브 ↔️ Flutter
- Expo ↔️ react-native-cli
- 리액트 네이티브에서 axios 말고 fetch 쓰는 이유
- iOS, Android와 RN이 상호작용 하는 방식
- RN navigation

<br>

### 리액트는 프레임워크 or 라이브러리 ?

- 결론적으로 리액트는 사용자 인터페이스를 만들기 위한 JS 라이브러리 입니다.

- 프레임워크 란 애플리케이션 개발시 코드의 품질, 필수적인 코드, 알고리즘, 암호화, 데이터베이스 연동 같은 기능들을 어느정도 구성이 되어있는 뼈대(구조)를 제공하도록 만들어진 것을 말합니다. 제어 반전이 적용된 구조로 외부 라이브러리 코드가 프로그래머가 작성한 코드를 호출합니다.
- 원하는 기능 구현에 집중하여 개발할 수 있도록 필요한 기능을 갖추고 있는 것, 일정한 형태를 가지고 다양한 형태의 결과물을 만드는 것.
- 즉, 개발 구조나 설계시 제공되는 인터페이스 집합으로 어느정도 프로그래머가 제공된 프레임워크 구조에서 개발을 해야합니다.
  <br>

- 전통적인 프로그래밍 흐름을 따르는 라이브러리는 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용합니다.
- 라이브러리는 특정 기능에 대한 API(도구/함수)를 모은 집합입니다. 그 기능을 사용하기 위해 불러와서 호출하는 방식입니다.
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 동작하는 중에 필요한 기능이 있을때 능동적으로 라이브러리를 사용합니다.

<br>

- 즉, 애플리케이션의 flow 를 누가 제어하느냐에 따라 이 둘을 구분하게 됩니다.
- 따라서, 애플리케이션 흐름을 직접 제어하는 리액트는 라이브러리 입니다.

### 리액트를 사용하는 이유

- 리액트를 사용하는 이유
  1. 컴포넌트 기반의 화면 구성으로 유지보수가 용이
  2. virtual DOM 을 활용한 빠른 렌더링
  3. SPA(Single Page Application)
  4. 생태계가 넓고 다양한 라이브러리 사용이 가능하며, 리액트 네이티브를 활용하여 앱 개발까지 가능

### Virtual DOM

- Virtual DOM
  DOM(Document Object Model)은 XML 이나 HTML 문서에 접근하기 위한 일종의 인터페이스 입니다. DOM은 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕습니다.

  `HTTP response > DOM tree > CSSOM tree > Render tree > painting `

  DOM은 새로운 요청이 있으면 위와 같은 형태를 거쳐 리렌더링을 하게 됩니다.
  DOM의 속도는 느리지 않지만, 매번 새롭게 구성하기 때문에 변경되는 양이 많으면 퍼포먼스가 떨어지게 됩니다. 이를 개선하기 위해서 Virtual DOM을 사용하게 됩니다.

  리액트는 virtual DOM 을 사용하여 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다. 전체 UI를 Virtual DOM 에 리렌더링하고, 이전 내용과 현재 내용을 비교하여 바뀐 부분만 실제 DOM에 적용시킵니다.

  리액트와 Virtual DOM 이 언제나 제공할 수 있는 것은 바로 업데이트 처리의 간결성 입니다.
  UI를 업데이트 하는 과정에서 생기는 복잡함을 모두 해소하고, 더욱 쉽게 업데이트에 접근할 수 있습니다.

### 리액트에서 클래스 컴포넌트와 함수 컴포넌트의 차이

#### 클래스 컴포넌트

- 객체 지향 프로그래밍 구조를 띄고 있으며, state 초기화 하기 위해서는 constructor(생성자)함수를 필요로 합니다.
- 생성자 함수를 통해 state 를 초기화 해야 하기 때문에 함수 컴포넌트에 비해 코드가 길어지고 사이즈가 커질 수 있습니다.
- state 기능 및 라이프 사이클 기능을 사용할 수 있으며 임의의 메서드를 정의할 수 있습니다.
- render 함수가 꼭 있어야 하며, 그 안에서 보여주어야 할 JSX 를 반환해야 합니다.

#### 함수 컴포넌트

- Hooks 를 이용하여 생성자 함수 통해 state 초기화를 하지 않아도 사용이 가능합니다.
- 선언하기가 좀 더 편한하고 메모리 자원을 덜 사용합니다.
- 제공되는 Hook 함수 뿐만 아니라 커스텀 Hook 을 생성하여 동작시킬 수 있습니다.
- 프로젝트를 완성하여 빌드한 후 배포할 때에도 함수 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작습니다.
- 함수 컴포넌트는 state 와 라이플 사이클 API 의 사용이 불가능 했었는데, v16.8 업데이트 이후에 적용된 Hooks 를 통해 이를 해결할 수 있게 되었습니다.

### 리액트에서 함수형 컴포넌트라고 부르지 않고 함수 컴포넌트라고 부르는 이유

- 리액트에서 사용하는 함수 컴포넌트는 Hook 을 사용하고, 이 Hook 으로 Side Effect 를 빈번히 일으키기 때문에 함수형 프로그래밍이 아닙니다.

함수형 프로그래밍은 순수 함수를 지향하는데, Side Effect 를 빈번히 일으키는 리액트의 함수 컴포넌트가 함수형 컴포넌트로 보기에는 어려움이 있습니다.

### props 와 state 차이

- props : props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props 를 읽기 전용으로만 사용할 수 있습니다. props 를 바꾸기 위해선 부모 컴포넌트에서 변경해야 합니다.

- state : 컴포넌트 내부에서 바뀔수 있는 값을 의미합니다.

### props가 컴포넌트간에 전달받는 것이라고 했는데 자식에서 부모로도 전달할 수 있는가

- props 는 부모 컴포넌트에서 설정할 수 있으며, 부모에서 자식으로만 데이터를 줄 수 있습니다.
- 자식 props 를 통해 부모에게 데이터를 줄 수 없고, 함수를 이용해야 합니다.
- 부모가 함수를 넣어서 props 로 넘겨주면, 자식이 데이터를 파라미터로 넣어 호출하는 방식으로 동작합니다.
- 즉, 부모가 props 로 함수를 넘겨주면, 자식이 그 함수를 이용해 값을 건네주는 방식입니다.

### FLUX

- 리덕스는 메타(구 페이스북)에서 리액트가 함께 소개한 FLUX 아키텍쳐로 구현한 라이브러리 입니다.
- FLUX 란 라이브러리나 프레임워크가 아닌 추상적인 개념입니다.
- MVC 패턴에서 쌍방향적인 데이터 흐름을 강조했던 것과 달리, FLUX 패턴에서는 단방향 데이터 흐름을 강조합니다.
- MVC 패턴의 경우 사용자의 어떠한 행위(액션)가 있을 때, 이를 바탕으로 설계된 컨트롤러를 통해 모델을 변화하고 이를 뷰에 반영합니다. 모델과 뷰가 복잡하게 얽히게 되면 뷰가 변경되었는지 제대로 확인할 수 없게 됩니다.
- 이를 해결하기 위해 나온 단방향 데이터 흐름을 제어하는 패턴이 FLUX 입니다.
- 사용자의 행위 Action 은 Dispatcher 에 의해 통제되고, Dispatcher 가 Store 를 업데이트 하고 변경된 Store 에 대한 뷰를 리렌더링 합니다.
- FLUX 패턴은 단방향적인 데이터 흐름 구조를 통해 어떤 액션이 디스패처에 의해 어떤 결과를 낳고 변화하는지 명확하게 알 수 있습니다.

### 상태 관리 도구의 필요성

- 상태?

  - React 에서 State 는 component 안에서 관리되고 시간이 지나면서 바뀌는 동적인 데이터
  - Component 간의 정보 공유
    - 자식 컴포넌트들 간의 다이렉트 데이터 전달은 불가능
    - 부모 컴포넌트를 통해 주고 받게 되는데 자식 컴포넌트들이 많아지면 상태 관리가 매우 복잡해짐
    - 상태를 관리하는 상위 컴포넌트에서 계속 내려받아야 함(Props Drilling 이슈)

- 이러한 상태 관리의 복잡성을 해결해주는 라이브러리를 활용!

  - 전역 상태 저장소를 제공하여, 어디서든 해당 저장소에 접근할 수 있어 Props Drilling 이슈를 해결할 수 있습니다.

- 좋은 상태 관리란?

  - State 는 관련 컴포넌트들과 최대한 가까이 배치되는 것이 좋습니다.
  - State 가 관련 컴포넌트와 멀어질수록 상태와 컴포넌트 사이에 있는 관련 없는 컴포넌트의 리렌더까지 일으킬 위험이 큽니다.
  - 또한 State 들은 관심사에 따라 잘 분리가 되어야 코드 수정시 Side Effect 를 최소화 할 수 있습니다.
  - 서로 관련 없는 컴포넌트들의 상태가 한번에 관리되면 결합도가 높아지게 되고 후에 어플리케이션이 비대화 될수록 의도치 않은 영향을 줄 수 있는 가능성이 높아지기 때문입니다.
  - 코드들은 격리되어 있지 않아 코드의 재사용성 또한 떨어집니다.

- 상태 관리 종류

  - React Context
  - Redux
  - MobX

- 가장 많이 사용되는 상태 관리 라이브러리는 Redux 입니다.

### 리덕스

<img src="https://velog.velcdn.com/images%2F404%2Fpost%2Fc8b85412-db74-49f3-b223-e0a35e1465b6%2Fredux-data-flow.gif" alt="redux">

- 리덕스란 자바스크립트 상태관리 라이브러리 이며, 가장 많이 사용되고 있는 라이브러리 입니다.
- React + Flux 구조에 Reducer 를 결합한 Redux
- 리덕스는 리액트, 앵귤러, 바닐라js 등 이용이 가능한 라이브러리
- 리덕스는 전역 상태 저장소를 제공하기 때문에 리액트의 Prop Drilling 문제와 여러 복잡해지는 상태 공유에 따른 컴포넌트 간 의존성 문제를 해결합니다.
- 리덕스는 Store 라는 하나뿐인 데이터 공간을 가지고 있으며, 이 공간에서만 데이터가 나옵니다.
- 리액트에서는 setState 메소드를 활용해야지만 상태 변경이 가능하듯, 리덕스에서도 Action 이라는 객체를 통해서만 상태 변경이 가능합니다.
- 변경은 순수 함수로만 가능하며, 이는 리듀서와 연관되는 개념입니다.

- 리덕스는 이럴때 사용합니다.

  - 앱의 여러 위치에서 필요한 많은 양의 상태들이 존재할 때(전역 상태가 필요하다고 느껴질 때)
  - 상태들이 자주 업데이트 될 때
  - 상태를 업데이트 하는 로직이 복잡할 때
  - 많은 사람들에 의해 코드가 관리될 때
  - 상태가 업데이트 되는 시점을 관찰할 필요가 있을 때

- 리덕스의 세가지 원칙

1. 하나의 애플리케이션 안에는 하나의 Store만 사용하자!
2. 상태를 변화시키는 것은 오직 Action 을 일으키는 것!
3. 변화를 일으키는 Reducer 함수는 순수 함수이어야만 한다!

- Reducer 함수는 이전 상태와 액션 객체를 파라미터로 받음
- 파라미터 외의 값에는 의존하면 안됨
- 이전 상태는 절대 건들지 않고, 변화를 준 새로운 상태 객체를 만들어 반환
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환

- Store

  - 상태가 관리되는 오직 하나의 공간으로, 컴포넌트와는 별개로 스토어 라는 공간이 있어서 그 스토어 안에 앱에서 필요한 상태를 담습니다.
  - 컴포넌트에서 상태 정보가 필요할 때 스토어에 접근합니다.

- Action

  - 앱에서 스토어에 운반할 데이터를 말합니다. 자바스크립트 객체 형식으로 되어 있습니다.

- Reducer

  - Action 을 Reducer 에 전달하고, 이 Reducer 가 Store 상태를 업데이트 합니다.
  - Action 을 Reducer 에 전달하기 위해서는 dispatch() 메소드를 사용합니다.
  - 즉, Action 객체가 dispatch() 메소드에 전달되고, dispatch() 를 통해 Reducer 를 호출하여 Reducer 는 새로운 Store 를 생성합니다.

- 이러한 공식을 따르는 이유는 `데이터가 한 방향으로만 흘러야 하기 때문` 입니다.

- Redux 에서 이를 구현하는 두 가지 방법은

- mapStateToProps()
- Redux hooks

  - useSelector
  - useDispatch

- Redux 장점

  - 데이터의 중앙집권화
  - 컴포넌트 상태 관련 로직을 따로 분리시켜 효과적으로 관리할 수 있고,
  - 상태를 공유할 때에도 다른 컴포넌트를 거치지 않고 Store 를 통해 전달이 가능하여 편리합니다.
  - 유지보수에 용이
  - 데이터가 단방향으로 흐르기 때문에 버그를 에측하기 쉽고, 디버깅에 유리
  - 순수함수를 사용하기 때문에 상태 예측이 가능하고, 데스트를 붙이기 용이합니다.

- Redux 단점

  - 초기에 state 업데이트에 맞는 Action 값들과 dispatch(), Reducer 들 등 미리미리 전부 만들어줘야 하기 때문에 복잡합니다.

<br>

### 리액트에서 리덕스를 이용한 상태 관리하기

1. 리액트 프로젝트에 모듈을 다운 받음

- npm install redux react-redux
- package.json 에서 확인 가능

2. 코드 분할(Code Splitting)

- 스크립트를 하나의 큰 파일로 로드하는 대신 더 작은 부분으로 나누고 해당 페이지에 필요한 것만 로드하는 기술
- src 폴더 안에 actions, reducers, store, components, pages 폴더로 분할
- 이때, components 폴더는 프리젠테이션 컴포넌트, pages 폴더는 컨페이너 컴포넌트로 나눔
- Store 는 하나의 리듀서만 관리할 수 있지만, 리듀서를 여러개 나눠서 하나로 합치는 것 가능

3. Reducer 에서 순수함수로 상태 업데이트 하는 방법

- Object.assign() 이용
- `return Object.assign({}, state, {새로 업데이트 할 것})`
- Spread 문법
- `return {...state, {새로 업데이트 할 것}}`

4. 최상위 index.js 에 Store 를 연결

<br>

### 리액트에서 state의 불변성을 유지해야 하는 이유

- 리액트에서 state값이 객체인 경우 setState를 통해 상태값을 업데이트 시킬때, spread operator를 사용해서 기존의 state값은 유지시키고 그것을 복사해서 업데이트한 값으로 상태를 바꿔줍니다. 이는 리액트에서 불변성을 지켜야 하는 이유와 관련이 깊습니다.
- 불변성은 어떤 값을 직접적으로 변경하지 않고 새로운 값을 만들어내는 것입니다.
- 이 불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못하게 됩니다.
- 우리가 state를 바꾸고 돔을 다시 만들려면, 새로운 객체나 배열을 만들어 새로운 참조값을 만들고 react에게 이 값은 이전과 다른 참조값임을 알려야 합니다.
- 따라서 기존의 state 값은 변하지 않도록 불변하게 만들고 새롭게 복사한 객체로 업데이트를 시켜 이전과 다른 값임을 알려야 합니다.
- 이렇게 state 값을 포함한 변수도 불변성을 갖게 해야 다른 버그나 예외사항이 일어나지 않는다.

- React에서 immutable variable을 만드는 여러가지 방법이 있습니다.
  - 자바스크립트 표준 함수 ES6 Object.assign() 또는 object-rest-spread
  - 자바스크립트 라이브러리 immutable-js
  - react공식 문서에서 추천하는 패키지인 immutability-helper

### 리듀서 내부에서 불변성을 지키는 이유? 전개 연산자의 단점을 해결할 수 있는 방법

- 컴포넌트는 총 4가지 경우에 업데이트를 합니다.

  - props 변경
  - state 변경
  - 부모 컴포넌트가 리렌더 될 때
  - this.forceUpdate 로 강제로 렌더링 트리거할 때

- 리듀서는 서버에서 넘겨받는 정보를 저장하고 전역으로 해당 객체를 사용할 수 있는 저장소 역할을 합니다.
- 불변성을 지킴으로써 각각의 고유한 참조값을 가지는 객체를 복사해서 사용함으로써 어떤 함수가 호출됐을 때 같은 객체를 참조한다면 생길 수 있는 불필요한 리렌더링과 부수효과를 줄일 수 있습니다.
- 하지만 `...spread` 연산자 사용해 객체를 복사하여 사용할 경우 객체의 깊이에 따라 로직 구성이 어려울 수 있습니다. (spread 연산자는 1depth 값에서만 깊은 복사를 실행함)
- 이를 해결하기 위한 라이브러리가 immer 라이브러리
- produce, draft 키워드 사용하여 spread 연산자 사용하지 않고 불변성을 유지해주며 불필요한 부수효과(Side Effect)를 막아줍니다.

### 리액트 사용시에 부수효과로 인해 생기는 문제점

- 부수효과(Side Effect)는 함수가 만들어진 목적과는 다른 효과 또는 부작용 입니다.
- 함수에 예상할 수 없는 일이 생길 가능성이 존재한다면 이 함수는 부수 효과를 가질 수 있는 함수가 됩니다.

### 부수 효과를 일으키는 함수(불순 함수)

- 비동기 요청을 보내는 함수는 요청에 실패할 가능성이 있고,
- 매개변수로 들어온 값을 직접 변경하는 함수,
- 입력을 포함하는 함수도 입력에 따라 출력이 달라질 가능성이 있어서 순수함수가 될 수 없습니다.

### 부수 효과를 일이키지 않는 함수(순수 함수)

- 함수의 매개변수로 들어온 값을 직접 변경하지 않는 것으로도 순수함수가 될 수 있습니다.

```js
// 매개변수의 값을 직접 변경하는 불순 함수
const addSixImpure = (arr) => {
  // 매개변수에 직접 추가
  arr.push(1);
  return arr;
};

// 매개변수를 복사한 값을 변경하는 순수 함수
const addSixPure = (arr) => {
  newArr = [...arr, 1];
  return newArr;
};
```

- 순수함수가 많아질 수록 코드를 더 쉽게 예측할 수 있고,
- 선언된 변수들을 직접 조작하지 않을수록 함수들은 부수효과 없이 개발자들의 의도대로 움질일 가능성이 높습니다.

- 즉, React state 는 직접 조작을 피하는 방식으로 부수효과를 방지합니다.
  (state, props 가 변경될 때 리렌더링 되기 때문에 의도치 않게 부수효과를 가진 함수들로 인해 불필요한 리렌더링이 잦아질 수 있습니다.)

- Redux 의 Reducer 는 순수 함수이어야만 하는데, store 값을 변경하는 함수가 부수효과를 동반하지 않아야 store 내부의 값들이 안전하게 보호될 수 있기 때문입니다.

- 또한 순수함수는 같은 입력에 대해 항상 같은 출력값을 보장하기 때문에, 테스트가 용이합니다.

- 부수효과가 있는 배열의 프로토타입 메서드
  - Array.isArray
  - Array.prototype.indexOf
  - Array.prototype.push (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.pop (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.unshift (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.shift (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.concat
  - Array.prototype.splice 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.slice
  - Array.prototype.join 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.reverse 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.fill 🌟 (원본 배열을 변경한다 - 부수효과 o)
  - Array.prototype.includes

### 컴포넌트의 라이플 사이클 메서드

- will 접두사가 붙은 메서드 : 어떤 작업을 작동하기 전에 실행되는 메서드
- Did 접두사가 붙은 메서드 : 어떤 작업을 작동한 후에 실행되는 메서드
- 이 메서드들은 우리가 컴포넌트 클래스에서 덮어써 선언함으로서 사용할 수 있습니다.
- 라이프 사이클은 총 3가지(마운트, 업데이트, 언마운트) 카테고리로 나눕니다.

- 마운트

  - DOM 이 생성되고 웹 브라우저상에 나타나는 것을 마운트라고 함
  - componentDidMount : 컴포넌트가 웹 브라우저 상에 나타난 후 호출하는 메서드

- 업데이트

  - props 변경
  - state 변경
  - 부모 컴포넌트가 리렌더링 될 때
  - this.forceUpdate 강제로 렌더링 트리거할 때
  - componentDidUpdate : 컴포넌트 업데이트(리렌더링) 후 호출하는 메서드

- 언마운트
  - 컴포넌트를 DOM 에서 제거하는 것
  - componentWillUnmount : 컴포넌트가 웹 브라우저 상에서 사라자기 전에 호출하는 메서드

### Hooks

- 리액트 버전 16.8에 새로 도입된 기능으로
- 함수 컴포넌트에서도 상태 관리 할 수 있는 useState,
- 렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공하여
- 기존의 함수 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해줍니다.

  - useState

    - 가장 기본적인 Hook
      `const [state, setState] = useState(초기값)`
    - state 는 변수, setState 는 state 를 변경시켜주는 함수
    - state, setState 를 return 하면서 초기값을 설정해주는 Hook
    - setState 함수를 이용하여 값을 변경해야지만 state 값이 변경되었다는 것을 인식하여 화면을 렌더링 합니다.
    - useState 는 리렌더링이 될 때 새로운 함수를 만들어주며, 각각의 함수는 고유의 state와 props를 기억하고 있습니다.

  - useEffect

    - 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정해주는 Hook
    - useEffect 는 기본적으로 렌더링 되고 난 직후마다 실행되며, 두번째 파라미터 배열, 즉 의존성 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.
    - 컴포넌트가 렌더링 된 이후에 어떤 일을 수행할 지 정해줄 수 있습니다.
    - 페이지가 처음 렌더링 되고 난 후 useEffect 는 무조건 한번 실행됩니다.
    - useEffect 에 배열로 지정한 useState 값이 변경될 때 실행되게 합니다.
    - 처음 렌더링만 실행하고 싶을 때는 의존성 배열에 빈배열을 작성합니다.
      `useEffect(() => {작업 내용}, [])`
    - 특정 값이 업데이트 될 때만 실행하고 싶다면, 의존성 배열에 useState 를 통해 관리되는 상태값이나 props 로 전달받은 값을 넣어주면 됩니다.
      `useEffect(() => {작업 내용}, [특정 값 업데이트를 위한 값])`

  - useReducer
    - useState 보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용하는 Hook
    - Reducer 는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션 값을 전달 받아 새로운 상태에 반환하는 함수 입니다.
    - Reducer 함수에서 새로운 상태를 만들 때는 반드시 불변성을 지켜주어야 합니다.
  - useMemo
    - useMemo 를 사용하면 함수 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.
    - 특정 `값` 이 바뀌었을 때만 연산을 실행하고, 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식입니다.
  - useCallback
    - useCallback 을 사용하면 렌더링 성능 최적화가 가능합니다.
    - 이 Hook을 사용하면 만들어놨던 함수를 재사용할 수 있습니다.
    - useCallback 의 첫번째 파라미터에는 생성하고 싶은 함수를 넣고, 두번째 파라미터에는 배열을 넣으면 됩니다.
    - 두번째 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야 합니다.
  - useRef
    - 바닐라 자바스크립트에서 특정 DOM 요소를 조작하기 위해 querySelector 혹은 getElementById 등을 사용했다면,
    - 리액트에서 특정 DOM에 접근할 때 useRef Hook 을 이용합니다.
    - useRef 는 .current 프로퍼티에 변경 가능한 값을 담고있는 객체입니다.
    - .current 프로퍼티를 변경하더라도 리렌더링을 유발하지 않습니다.
    - ref 객체 안의 값은 리액트 생명주기에 독립적 이기 때문입니다.
  - useMemo ↔️ useCallback

    - 리액트에서 사용하는 컴포넌트는 다음과 같은 경우에 리렌더 됩니다.

      - props 변경
      - state 변경
      - 부모 컴포넌트가 리렌더링 될 때

    - 불필요한 렌더링은 성능 저하에 가장 큰 원인이 되기도 합니다.
    - 이렇게 특정 상황(값 또는 함수 변경)에 맞게 리렌더링 될 수 있도록 useMemo 와 useCallback 을 사용합니다.
    - 의존성 배열을 사용하여 어떤 값에 의해 의해 확인될 수 있도록 합니다.

    - useMemo 는 메모이제이션된 `값`을 반환
    - useCallback 은 메모이제이션 된 `함수`를 반환
    - `메모이제이션` : 프로그램 실행 시 이전에 계산한 값을 저장, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식

### 리액트에서 setState는 비동기 or 동기?

- state 값을 갱신하는 setState 함수는 비동기로 동작하는 Hook 함수 입니다.
- 리액트는 state, props 값의 변경에 따라 리렌더링이 일어납니다.
- setState 를 비동기 함수로 처리해서 컴포넌트 내 비동기 함수를 처리하는 콜백 큐가 비워지면 리렌더링 되도록 설계합니다.
- 즉, 해당 함수 내에서 동기적으로 실행되는 함수가 모두 실행된 뒤에 마지막에 setState 를 처리한다.

### setState가 비동기 동작을 취했을 때 얻을 수 있는 이점

- setState 가 비동기 동작을 취함으로써 자바스크립트 내의 실행 컨텍스트 스택이 돌아갈 때 동기적으로 실행되는 함수들을 모두 동작한 뒤에 큐에 존재하는 비동기 함수들을 이벤트 루프에 의해 꺼내와서 실행시킵니다.
- 불필요한 리렌더링을 줄여줘서 성능이 개선됩니다.

### 리액트의 성능개선 방법

- 리액트는 단방향 하향식 데이터 흐름을 가지고 있습니다.
- 즉, 데이터는 부모 컴포넌트에서 자식 컴포넌트 방향으로 흘러갑니다.
- 이 데이터들(props, state)의 변화는 컴포넌트를 리렌더링 시킵니다.
- props 는 부모 컴포넌트로 부터 받은 데이터, state 는 선언된 컴포넌트 내에서 사용됩니다.

- 따라서 이미 만들어진 프로젝트에서의 렌더링 최적화는

  1. state 와 props 의 변경을 최소화 하는 것
  2. state 와 props 의 변경에 의해 불필요한 하위 컴포넌트 리렌더링을 최소화 하는 것

- 이 두 가지 방향으로 진행됩니다.

1. state 의 선언 위치

- 해당 state 를 사용하는 컴포넌트 중 가장 최상위 컴포넌트에 선언합니다.

2. 객체 타입의 state 를 최대한 분할하여 선언하기

3. React.memo 를 이용한 컴포넌트 메모이제이션

- React.memo 는 컴포넌트를 래핑하여 props 를 비교하여 리렌더링을 막을 수 있는 메모이제이션 기법을 제공하는 함수입니다.
- React.memo 는 콜백 함수를 이용해 메모이제이션 적용 여부를 판단할 수도 있습니다.
- React.memo 를 이용하여 변경된 값만 렌더링 하고, 기존에 렌더링 된 것은 리렌더 되지 않도록 할 수 있습니다.
- 메모이제이션 기법을 적용했으므로 변경된 값만 리렌더링 됩니다.

4. 컴포넌트를 매핑할 때 key 값으로 index 사용하지 않기

- 리액트에서 컴포넌트를 매핑할 때 반드시 고유 key 값을 부여하도록 강제하고 있는데, 이때 배열의 index 값을 사용하면 어떤 배열에 중간에 어떤 요소가 삽입이 되면 그 중간보다 이후에 위치한 요소들 전부 인덱스가 변경됩니다.
- 이로 인해 key 값이 변경되고 리마운트가 일어나게 됩니다.
- 또한 데이터가 key 와 매치되지 않는 부작용도 발생하게 됩니다.
- 따라서 배열의 index 값 대신 고유 id 값을 넣어주는 것이 바람직 합니다.

5. useMemo, useCallback 이용하여 불필요한 렌더링 방지
6. 하위 컴포넌트의 props로 객체를넘겨주는 경우 새 객체 생성 주의하기

- state를 그대로 하위 컴포넌트에 넘겨주어 필요한 데이터 가공을 넘겨받은 하위 컴포넌트에서 해주는 것이 좋습니다.

### SSR ↔️ CSR

- SSR(Server Side Rendering) 은 서버에서 사용자에게 보여줄 페이지를 모두 구성해서 보여주는 방식입니다.
- 서버에서 모두 구성해서 사용자에게 보여주기 때문에 초기 렌더 속도가 빠릅니다.
- 또한 잘 갖춰진 HTML 문서를 사용자에게 보여주기 때문에 효율적인 SEO(검색엔진 최적화)가 가능하다는 장점을 가집니다.
- 하지만 요청시마다 새로고침이 일어나며 서버에 새로운 페이지에 대한 요청하는 방식이어서, 기술의 발전으로 인해 웹에서 제공되는 정보량이 많아짐에 따라 불필요한 렌더링이 일어난다는 단점이 있습니다.

- CSR(Client Side Rendering) 은 쉽게 말해서 클라이언트에서 모두 처리를 해주는 것인데, 서버에서 전체 페이지를 한번 렌더링 하여 보여주고 사용자가 요청할 때마다 리소스를 서버에서 제공받아 클라이언트가 해석하고 렌더링 하는 방식 입니다.
- 서버에 HTML 문서 요청하는 것이 아니라, 브라우저에서 자바스크립트로 콘텐츠를 렌더링 하는 것입니다.
- HTML 이 텅텅 비어있어 처음 접속하면 빈 화면이 보이고, 링크된 자바스크립트를 다운로드 받게 됩니다. 여기엔 애플리케이션에 필요한 로직, 프레임워크, 라이브러리 소스 코드 들이 모두 포함되어 있어서 처음 다운로드 받을 때 꽤나 시간이 소요될 수 있습니다.
- 따라서 초기 렌더 속도가 SSR 에 비해 느리다는 단점이 있습니다.
- 또한 초반에 HTML 문서가 대부분 텅 비어있기 때문에 SEO(검색엔진 최적화) 에 유리하지 못합니다.

<br>

### 리액트는 대표적인 CSR 인데, SSR 을 사용하는 이유는 ?

- 가장 큰 이유는 효율적인 SEO(Search Engine Optimization) 을 위해서 입니다.
- SEO 는 검색 엔진들이 우리 웹사이트에서 html 태그 안의 내용을 분석하여 사용자가 입력한 정보를 바탕으로 알맞은(사용자가 원하는) 정보를 찾을 수 있게 하는 기능입니다.
- 리액트는 CSR 으로 작동되는데, 사용자가 우리의 해당 도메인에 접속하면 클라이언트 쪽에서 html 과 js 등의 파일을 다운받아 보여주는 형식입니다.
- CSR 상태에서는 사전에 html 이 대부분 비어있기 때문에, 검색 엔진에 노출되는 빈도가 현저히 적거나, 해당 정보가 노출되지 않아서 검색해도 나오지 않을 수 있습니다.
- 그래서 SSR 을 통해서 사전에 htlm 과 일부 js 파일을 넘겨주게 되면, 빠른 초기 렌더 속도는 물론, 검색 엔진에서 이를 캐치하여 사용자가 원하는 정보가 담긴 우리 사이트를 보여줄 수 있습니다.
- SSR 적으로 바꿔 주기 위해서 next.js 와 같은 라이브러리를 사용합니다.

### SSR 의 단점

- Blinking Issue
  - 사용자가 새로고침 하게되면 전체 웹사이트를 다시 서버에서 받아와야 하기 때문에 화면이 없어졌다 나타나는 깜빡임 현상이 존재
- 서버 과부하
  - 사용자가 많은 제품일수록 서버에 데이터 요청을 하는 횟수가 많아지기 때문
- TTV(Time To View) 와 TVI(Time To Interact) 의 공백시간

### TTV , TVI

- SSR 방식에서는 서버에서 만들어진 HTML 파일을 가져오게 되고 사용자는 바로 웹 사이트를 볼 수 있습니다.
- 하지만, 웹 사이트를 동적으로 제어할 수 있는 자바스크립트 파일은 아직 받아오지 않았기 때문에 사용자가 클릭을 해도 아무 것도 처리할 수 없는 상태가 됩니다.
- 최종적으로 자바스크립트 파일을 받아와야지만 사용자가 원하는 것을 처리할 수 있는 인터랙션이 가능해집니다.
- 따라서 SSR 은 사용자가 사이트를 볼 수 있는 시간(TTV) 과 실제로 인터랙션이 가능한 시간(TTI)의 공백시간이 꽤 길다는 단점이 존재합니다.

↔️ CSR 은 html 만 받아왔을 때는 아무것도 보여지지 않고, 자바스크립트 파일을 받아오게 되면 웹 사이트가 보여지는 동시에 인터랙션이 가능합니다. 즉, TTV 와 TTI 공백시간이 없는 것입니다.

### 좋은 CSR, SSR 개발자가 되기 위해서

- CSR 을 잘 사용하기 위해선 최종적으로 번들링 해서 사용자에게 보내주는 자바스크립트 파일을 어떻게 하면 효율적으로 많이 분할해서, 첫번째로 사용자가 사이트를 보기 위한 필요한 필수적인 요소들만 보낼 수 있을지 고민해야 합니다.
- SSR 의 경우 TTV 와 TVI 공백 시간을 줄이기 위해서 어떤 노력을 할 수 있을지, 좀 더 매끄러운 UI와 UX 를 제공할 수 있을지 고민해야 합니다.
- 요즘에는 CSR, SSR 말고 SSG(Static Site Generation) 도 존재합니다.

### SSG

- Static Site Generation
- SSR 처럼 서버로부터 완성된 HTML 을 받아오지만, 다른 점은 HTML 파일의 생성시점이 `빌드 타임(npm run build)` 이라는 것입니다.
- 여기서 Static 는 HTML 이 정적인 것을 뜻함
- 페이지에 대한 사용자들의 요청이 발생하게 되면, 요청에 따라 계속 서버에서 재생성 하는 것이 아니라 이미 생성 완료된 페이지를 반환해주게 됩니다.

- 장점

  - 생성이 완료된 HTML 문서를 재활용 하기 때문에 응답 속도 빠름
  - 이미 생성된 HTML 파일을 받기 때문에 SEO 친화적
  - build 명령은 실제로 사이트를 방문하는 사람의 워크플로를 벗어나므로 시간이 걸리더라도 문제되지 않음

- 단점
  - 모든 URL 에 대해 개별 HTML 파일을 생성해야 함. 따라서 URL 을 미리 예측할 수 없으면 적용이 어려움

### 하이드레이션

- 리액트에서 SSR 혹은 SSG 을 실행한 HTML 결과물을 받아온 뒤, 브라우저에서 이것을 다시 리액트 트리에 맞게 파싱하는 행위 입니다.

### SPA 장단점

- SPA(Single Page Application)은 단일 페이지로 구성된 웹 애플리케이션으로,
- 어떤 웹사이트 전체 페이지를 하나의 페이지에 담아서 동적으로 화면을 바꿔가면서 보여주는 것을 말합니다.
- 첫 로딩시 전체 페이지를 로딩하고 필요한 데이터만 json 형태로 받아 동적으로 렌더링 하는 방식입니다.
- 화면 구성에 필요한 모든 HTML 요소를 클라이언트가 가지고 있고, 서버에서 필요한 데이터 요청을 json 형태로 받기 때문에 화면을 구성하는 속도가 빠릅니다. (CSR 방식을 따름)
- 대표적인 SPA 라이브러리에 `리액트` 등이 있고, 그 외 `번들링 팩`, `트랜스 컴파일링`을 지원하기 위한 `node.js 기반` `웹팩`, `바벨` 등도 SPA 를 위한 주요 라이브러리 입니다.
- 라우팅 이란 다른 경로(url)에 따라 다른 화면을 보여주는 것을 말하는데, 리액트 라이브러리 자체에는 이 기능이 내장되어 있지 않기 때문에 라이브러리를 사용하는 등의 방법으로 구현할 수 있습니다.
- 리액트 라우터, 리치 라우터, Next.js 등 여러가지의 리액트 라우팅 라이브러리가 존재합니다.

#### SPA 장점

- Virtual DOM 구현으로 새로운 페이지 요청 시 변경되는 부분만 갱신하기 때문에 전체적인 트래픽 감소와 렌더링에서 좋은 효율을 가집니다.
- 새롭게 갱신되는 부분만 렌더하기 때문에 새로고침이 발생하지 않아서 깜빡임 없이 빠른 화면 이동이 가능합니다.
- 트래픽의 감소와 속도, 반응성의 향상으로 인해 앱처럼 자연스러운 사용자 경험을 제공합니다.
- 컴포넌트형 기반의 구조로 코드 재사용성과 유지보수에 용이합니다.

#### SPA 단점

- SPA는 는 최초 서버로부터 거의 비어있는 HTML 파일을 로딩한 이후에 script 태그 내 존재하는 Javascript 가 작동하면서 필요한 컴포넌트를 요청하는 방식으로 작동합니다.
- 동적 애플리케이션 조작을 위해 Javascript 소스가 무거워 지면서 최초 페이지 접속시 대기 시간이 길어진다는 단점이 있습니다.
- 또한 SEO 에 취약한 구조를 가지고 있습니다. 구글 크롤봇은 웹페이지를 이동하면서 HTML 소스를 수집하고 사용자 쿼리에 적합한 페이지를 상단에 노출하는데, SPA 는 대부분 Javascript 로 작동하기 때문에 크롤봇이 수집할 HTML 소스가 부족하기 때문입니다.

### Next.js

- SPA 는 기본적으로 CSR 방식을 사용하여 동작하는데, SEO 단점을 극복하기 위해 SSR 개념을 부분 적용하고 싶을 수 있다.
- ReactDOMServer 를 이용해서 직접 설정을 구축하는 방법이 있지만 사전 설정에 들어가는 시간이 많이 소요되고, 러닝 커브가 높다.
- 이보다 더 간편하게 SSR 방식을 적용하기 위해 개발된 프레임워크가 있는데 그 중 대표적인 것은 Next 와 Gatsby 가 있다.
- NEXT 는 브라우저에 렌더링 할 때 기본적으로 pre-redering(사전 렌더링)을 합니다.
- pre-rendering 이란 각 페이지들을 사전에 미리 HTML 문서로 생성하여 가지고 있는 것입니다.
- CSR 방식으로 번들링 된 js 가 클라이언트 단에서 모든 추가 렌더링을 담당했다면, Next의 pre-rendering 시스템에서는 `빌드 타임 때` 해당하는 페이지 별로 각각의 HTML 문서를 미리 생성해서 가지고 있다가 서버로 요청이 들어올 때 알맞은 페이지를 반환해줍니다.
- 사실 pre-rendering 이란 렌더가 완전히 준비된 HTML 파일을 만드는 것을 의미 합니다.
- 단지, NEXT 에서의 pre-rendering 이 default 값으로 SSG 가 적용되고 있을 뿐입니다. 또한 SSR 또한 SSG 에 속한다고 볼 수 있습니다. - 즉, 둘 다 pre-rendering 의 형식에 해당합니다.
- pre-rendering 을 하기 위한 두가지 형식

  - Static-Generation : HTML 을 빌드 타임에 각 페이지 별로 생성하고 해당 페이지로 요청이 들어올 경우 이미 생성된 HTML 문서를 반환
  - Server-Side-Rendering : 요청이 올 때 마다 해당하는 HTML 문서를 그때 그때 생성하여 반환

- Next 에서는 다음과 같은 경우에 Static-Generation 을 사용할 것을 권고합니다.

  - 퍼포먼스에 집중(CDN을 통해 더 빠른 응답 가능)
  - 마케팅 페이지 / 블로그 게시물 / 제품 목록 등과 같이 정적 생성하여 각 요청에 동일한 문서를 반환할 수 있는 경우

- SSR 방식은 이럴때 씁니다.
  - 항상 최신 상태 유지해야 하는 경우(요청에 따라 응답할 내용이 시시각각 변함)
  - 제품 상세페이지 / 분석 차트 등 요청 마다 다른 내용 또는 형식의 HTML 문서가 반환되는 경우

#### SSG (Static Site Generation) 동작 방식

1. 사용자가 웹 페이지를 방문하면(request), 엣지 캐싱된 HTML 클라이언트로 반환해줍니다.
2. 브라우저는 HTML 을 다운로드 하고 최종 사용자가 사이트를 볼 수 있도록 합니다.

<br>

- 엣지 캐싱(edge caching)이란?

최종 사용자에게 더 가까운 컨텐츠를 저장하기 위해 캐시 서버를 사용하는 것이다. 대표적으로 CDN을 많이 사용한다.

캐시 서버(Cache Server)는 인터넷 서비스 속도를 높이기 위해 사용자와 가까운 곳에 데이터를 임시 저장하여 빠르게 제공해주는 프록시 서버(클라이언트와 서버 사이에서 데이터를 전달해 주는 서버)를 의미한다.

CDN(Content Delivery Network): 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식
ex) aws의 cloudflare

### Next의 렌더링 수행 방식

1. SSR을 기반으로 서버에 사전에 저장된 렌더트리(render tree)의 HTML을 로드
2. ① 방식의 사전 렌더링(pre-render) 이후에는 CSR 사용
3. 페이지가 그려진 이후에 페이지 내부에서 동적인 데이터를 패치(axios, fetch, XMLHttpRequest)하는 과정은 CSR 방식을 따른다.
4. 만약 페이지가 로드될 때 함게 데이터가 패칭되어야 하는 상황이라면(pre-render)
5. next.js의 데이터 패칭 방식 (① getInitialProps/ ② getStaticProps / ③ getStaticPath / ④ getServerSideProps) 을 이용해 첫 렌더링 시에 HTML 파일 뿐만 아니라 데이터가 패칭될 수 있도록 처리해야 합니다.

### Next를 쓰는 이유

1. 사전 렌더링 및 서버 사이드 렌더링

서버 사이드 렌더링 기능을 제공하여 클라이언트 사이드 렌더링 환경보다 빠른 렌더링을 불러올 수 있습니다.

2. Hot Code Reloading을 지원

Next 개발 환경에서는 코드 변경 사항이 저장되면 응용 프로그램을 자동으로 다시 로드합니다.

3. 자동 코드 분할

자동 코드 분할 기능 덕분에 코드의 모든 가져오기각 번들로 묶여 각 페이지와 함께 제공됩니다. 결과적으로, 불필요한 코드가 페이지에 로드되지 않게 됩니다.

4. 설정이 필요없음

넥스트는 기본적으로 웹팩과 바벨을 사용하고 있습니다. 이미 서버 사이드 렌더링 및 개발에 필요한 설정이 되어 있으므로 빠르게 개발을 시작할 수 있습니다.

사용하고 싶은 플러그인이 있다면 손쉽게 추가하여 사용할 수 있도록 지원을 하고 있습니다.

5. 타입스크립트가 내장됨

6. 파일기반 내비게이션 기능

리액트에서는 라우트를 위해서 'react-router'라는 라이브러리를 사용하여 라우팅 설정을 해주어야 합니다.

그로 인해 페이지의 경로에 대하여 직접 설정을 해주어야 하였습니다.

하지만 넥스트는 파일 시스템 기반 라우팅을 사용합니다.

폴더의 경로에 따라 페이지의 경로가 설정되어 구축이 빠르고 관리가 편리하다는 장점이 있습니다.

### 리액트 네이티브에서 axios 말고 fetch 쓰는 이유

- axios 는 라이브러리로 다운받아 따로 import 해야 하지만, fetch 는 자바스크립트가 가진 내장 라이브러리 라서 따로 import 하지 않고도 쓸 수 있어서 빌드 시에 용량이 줄어든다.
- 또한 리액트 라이브러리는 버전이 빠르게 업데이트 되는 특성이 있기 때문에 최대한 라이브러리 의존성을 낮춰야 한다.
