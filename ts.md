## 목차

- 타입스크립트
- 왜 타입스크립트 를 쓰나요?
  - 에러의 사전 방지
  - 코드 가이드 및 자동 완성으로 인한 개발 생산성 향상
- 타입스크립트 기본 타입
  - String
  - Number
  - Boolean
  - Object
  - Array
  - Tuple
  - Enum
  - Any
  - Void
  - Null
  - Undefined
  - Never
- 제네릭(Generics)
  - 제네릭을 사용하는 이유
  - 제네릭이 없다면?

### 타입스크립트

- 자바스크립트의 확장된 언어로, 자바스크립트에 '타입'을 부여한 언어입니다.
- 타입스크립트는 자바스크립트와 달리 브라우저에서 실행하려면 파일을 한번 변환해주어야 하는데, 이 변환 과정을 `컴파일(complie)` 이라고 합니다.

### 왜 타입스크립트 를 쓰나요?

- 타입스크립트는 2가지 관점에서 자바스크립트 코드의 품질과 개발 생산성을 높일 수 있습니다.

1. 에러의 사전 방지
2. 코드 가이드 및 자동 완성으로 인한 개발 생산성 향상

#### 에러의 사전 방지

- 타입스크립트는 타입을 컴파일 시점에 정해주기 때문에 에러를 사전에 미리 예방할 수 있습니다.

#### 코드 자동 완성과 가이드

- 코드를 작성할 때 개발 툴의 기능을 최대로 활용할 수 있습니다.
- VS Code 는 툴의 내부가 타입스크립트로 작성되어 있어서 타입스크립트 개발에 최적화 되어 있습니다.
- 타입이 미리 지정되어 있기 때문에 VSCode 에서 해당 타입에 대한 API 를 미리 보기로 띄워줄 수 있는 등 개발 생산성을 향상 시켜줍니다.

### 타입스크립트 기본 타입

- String

  ```js
  let str: string = "hi";
  ```

- Number

  ```js
  let num: number = 10;
  ```

- Boolean

  ```js
  let isLoggedIn: boolean = false;
  ```

- Object
- Array

  ```js
  let arr: number[] = [1, 2, 3];

  // 제네릭 사용도 가능
  let arr: Array<number> = [1, 2, 3];
  ```

- Tuple
  - 튜플은 배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식
  ```js
  let arr: [string, number] = ["bbo", 10];
  ```
- Enum
- Any
  - 기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입
  - 단어 의미 그대로 모든 타입에 대해서 허용한다는 의미
  ```js
  let str: any = "hi";
  let num: any = 10;
  let arr: any = ["a", 2, ture];
  ```
- Void
  - 변수에는 undefined, null 만 할당하고, 함수에는 반환 값을 설정할 수 없는 타입
  ```js
  let unuseful: void = undefined;
  function notuse(): void {
    console.log("sth");
  }
  ```
- Null
- Undefined
- Never
  - 함수의 끝에 절대 도달하지 않는다는 의미를 지닌 타입
  ```js
  function neverEnd(): never {
    while (true) {}
  }
  ```

### 제네릭(Generics)

- 제네릭은 C#, Java 등의 언어에서 재사용성이 높은 컴포넌트를 만들 때 자주 활용되는 특징
- 특히, 한가지 타입보다 여러가지 타입에서 동작하는 컴포넌트를 생성하는데 사용됩니다.
- 제네릭은 데이터의 타입을 일반화 한다는 것을 뜻합니다.
- 제네릭이란 타입을 마치 함수의 파라미터처럼 사용하는 것을 의미합니다.

```js
function getText<T>(text: T): T {
  return text;
}
```

- 위 함수는 제네릭 기본 문법이 적용된 형태
- 이제 함수를 호출할 때 아래와 같이 함수 안에서 사용할 타입을 넘겨줄 수 있습니다.

```ts
getText<string>("hi");
getText<number>(10);
getText<boolean>(true);
```

- `getText<string>('hi)` 를 호출하면 함수에서 제네릭은 다음과 같이 동작합니다.

1. 먼저 위 함수에서 제네릭 타입이 `<string>` 이 되는 이유는 getText() 함수를 호출할 때 제네릭(함수에서사용할 타입) 값으로 string 을 넘겼기 때문입니다.

```ts
function getText<string>(text: T): T {
  return text;
}
```

2. 이 후 함수의 인자로 hi 라는 값을 아래와 같이 넘기면

```ts
getText<string>("hi");
```

3. getText 함수는 아래와 같이 타입을 정의한 것과 같습니다.

```ts
function getText<string>(text: string): string {
  return text;
}
```

위 함수는 입력 값의 타입이 string 이면서도 반환 값 타입도 string 이어야 합니다.

### 제네릭을 사용하는 이유

- 다른 자료형을 변환할 때 형 변환시 발생하는 오류를 미리 방지하고, 의도치 않은 자료형으로 지정되는 것을 막아주는 역할
- 자료형을 정하지 않고 여러 타입을 사용할 수 있게 해줍니다.
- 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법입니다.
- 한번의 선언으로 다양한 타입에 '재사용' 이 용이합니다.
- 제네릭을 쓰지 않으면 불필요한 타입 변환을 하기 때문에 성능이 악화될 수 있는데, 제네릭을 사용하면 따로 타입 변환을 할 필요가 없어서 프로그램 성능이 향상되는 장점이 있습니다.

### 제네릭이 없다면

- 타입을 미리 정하거나,
- any 를 이용하여 구현할 수 있다.
- 하지만 타입을 미리 지정하면 항상 number 라는 타입을 받아야 하므로 범용성이 떨어지고,
- any 를 사용하면 자료의 타입을 제한할 수 없을 뿐더러, 어떤 타입의 데이터가 리턴되는지 알 수 없다.
