## 목차

- 자료구조
- List
  - Array List
  - Linked List
  - Cotiguous List
  - Stack
  - Queue
  - Graph
  - Tree
- Set
  - HashSet
  - SortedSet
    - TreeSet
- Map
  - HashTable
  - HashMap
  - SortedMap
    - TreeMap

### 자료구조

- 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 자료구조 라고 합니다.
- 적절한 자료구조를 적용했을 때 자료를 더 효율적으로 저장하고 관리하며, 실행시간 단축 및 메모리 용량의 절약을 이끌어 낼 수 있습니다.

#### 자료구조의 선택 기준

- 자료의 처리시간
- 자료의 크기
- 자료의 활용 빈도
- 자료의 갱신 정도
- 프로그램의 용이성

#### 자료구조의 특징

- 효율성
  - 자료구조를 사용하는 목적은 데이터를 목적에 맞게 효율적으로 관리 및 사용하는 것
  - 적절한 자료구조를 선택하여 코드의 효율을 높임
- 추상화
  - 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만을 간추려 내는 것
  - 자료구조를 구현할 때 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 해당 데이터를 어떻게 사용할 것인지에 대해 초점을 맞출 수 있어서 구현 외적인 부분에 더 시간을 쏟을 수 있음
- 재사용성
  - 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계

#### 자료구조의 분류

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuGE5R%2FbtrhA3lOp6X%2FUK1vpqPfCfj874lMLygAI0%2Fimg.png" alt="data structure">

- 자료구조는 선형/비선형 으로 나뉘며,
- 선형 자료구조는 데이터가 일렬로 나열되어 있는 것을 뜻하고,
- 비선형 자료구조는 특정한 형태를 띄고 있는 것을 뜻합니다.

#### 선형 구조

- Array
- Linked List
- Stack
- Queue

#### 비선형 구조

- Set
- Table
- Graph
- Tree

### List

- 순서가 있고, 중복을 허용합니다.
- 인덱스로 원소에 접근이 가능합니다.
- 크기가 가변적 입니다.

#### Array List

- 단방향 포인터 구조롤 데이터 순차적 접근에 강점을 가집니다. (인덱스가 부여된 데이터)
- 배열을 기반으로 데이터를 저장합니다.
- 인덱스를 가지고 있어 데이터 검색이 빠릅니다.
- 하지만, 데이터 삽입과 삭제는 shift 연산 등 부수적인 작업이 필요하기 때문에 Linked List 에 비해 느립니다.

#### Linked List

- 양방향 포인터 구조로 메모리 주소값들이 매칭되어 있는 자료구조 입니다.
- 인덱스를 가지고 있지 않기 때문에 Array List 에 비해 데이터 검색이 느립니다.
- 하지만, 데이터 삽입과 삭제는 빠릅니다.

#### Contiguous List

- 연속 리스트는 배열처럼 연속적인 기억 장소에 데이터가 저장되는 자료구조 입니다.
- 연속적으로 데이터가 저장되어 있어 검색에는 용이하지만, 데이터의 삽입이나 삭제는 용이하지 않습니다.

#### Stack

- 순서가 유지되는 선형 데이터 구조입니다.
- 리스트의 한쪽에서만 데이터의 삽입과 삭제가 일어나므로, 가장 마지막 요소부터 가장 처음 요소를 처리하는 LIFO(후입선출) 메커니즘을 가지고 있습니다.
- 기억공간이 부족한 경우 데이터를 삽입하는 경우 Overflow 가 발생하고, 삭제할 데이터가 없을 때 데이터를 삭제하고자 하면 Underflow 가 발생합니다.
- 데이터를 받는 순서대로 정렬되고 메모리의 크기가 동적이지만 한번에 하나의 데이터만 처리할 수 있습니다.

#### Queue

- 큐는 스택과 비슷하지만 FIFO(선입선출) 메커니즘을 가지고 있습니다.
- 리스트의 한쪽에서는 삽입이 일어나고, 다른 쪽에서는 삭제가 일어납니다.
- 데이터의 시작 부분을 Front, 끝 부분을 Rear 라고 합니다.
- 동적인 메모리 크기와 빠른 런타임을 자랑하지만, 가장 오래된 요소만을 가져오고 한번에 하나의 데이터만 처리하는 단점을 가지고 있습니다.

#### Graph

- 정점(Vertex)과 간선(Edge)으로 이루어진 데이터 구조이며, 사이클이 없는 그래프를 특별히 트리라고 합니다.
- 방향 그래프와 무방향 그래프가 있습니다.
- 새로운 요소들의 추가나 삭제가 용이하고 구조를 용이하기에 적합합니다.
- 하지만, 데이터 간의 충돌이 일어날 수 있습니다.

#### Tree

- Node 로 구성된 계층적 자료구조 입니다.
- 최상위 노드(루트, Root)를 만들고 그 아래에 자식을 추가하는 방식으로 트리구조는 다양하게 구현할 수 있습니다.
- 노드와 노드를 잇는 선을 간선(Edge)이라 합니다.
- 같은 부모 노드를 가지며, 같은 레벨에 있는 노드를 형제(Siblings) 노드라 하고, 자식이 없는 노드를 단말(Terminal) 노드라고 합니다.

### Set

- 데이터의 집합이며, 순서가 없고 중복된 데이터를 허용하지 않습니다.
- 중복되지 않은 데이터를 구할 때 용이합니다.
- 빠른 검색 속도를 가집니다.
- 인덱스가 따로 존재하지 않기 때문에 iterator 를 사용합니다.

#### HashSet

- 인스턴스의 해시값을 기준으로 저장하기 때문에 순서를 보장하지 않습니다.
- Null 값을 허용합니다.
- TreeSet 보다 삽입, 삭제가 빠릅니다.

#### TreeSet

- 이진 탐색 트리(Red-Black Tree)를 기반으로 합니다.
- 데이터들이 오름차순으로 정렬됩니다.
- 데이터 삽입, 삭제는 시간이 걸리지만 검색, 정렬이 빠릅니다.

### Map

- key 와 value 의 한 쌍으로 이루어진 데이터의 집합 입니다.
- key 에 대한 중복이 없으며, 순서를 보장하지 않습니다.
- 뛰어난 검색 속도를 가집니다.
- 인덱스가 따로 존재하지 않기 때문에 itertor 를 사용합니다.

#### HashMap

- 검색에 가장 뛰어난 자료구조 입니다.
- key 에 대한 중복이 없으며, 순서를 보장하지 않습니다.
- 동기화가 보장되지 않습니다. (<-> HashTable)
- key 와 value 값으로 Null 을 허용합니다.

#### HashTable

- 동기화가 보장되어 있습니다.
- 병렬 프로그래밍이 가능하여 HashMap 보다 처리 속도가 빠릅니다.
- key 와 value 값으로 Null 을 허용하지 않습니다.

#### Linked HashMap

- 입력된 순서를 보장합니다.

#### TreeMap

- 이진 탐색 트리(Red-Black Tree)를 기반으로 key 와 value 를 저장합니다.
- key 값을 기준으로 오름차순 정렬되고, 빠른 검색이 가능합니다.
- 저장 시 정렬을 하기 때문에 시간이 다소 오래 걸립니다.

### List vs Set vs Map

- List 는 기본적으로 데이터들이 순서대로 저장되며 중복을 허용합니다.
- Set 은 순서가 보장되지 않고, 데이터들의 중복을 허용하지 않습니다.
- Map 은 순서가 보장되지 않고, key 값의 중복은 허용하지 않지만, value 값의 중복은 허용 됩니다.
